[
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/funktionen/",
	"title": "Funktionen",
	"tags": [],
	"description": "",
	"content": "Folgend ein summarischer Überblick über die Grundlagen von Metafacture, wobei für eine ausführlichere Erläuterung auf die offizielle Dokumentation verwiesen wird.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/funktionen/datenfelder/",
	"title": "Werte auslesen",
	"tags": [],
	"description": "",
	"content": "Werte einzelner Datenfelder können mit der Funktion data ausgelesen werden. In ihrer einfachsten Form hat data ein Attribut, source, welches dem Namen des auszulesenden Feldes entspricht. Dabei können auch Wildcards verwendet werden, so ? für ein beliebiges Zeichen und * für Sequenz arbiträrer Zeichen mit Länge 0-n. In dieser einfachsten Form - ausgeschrieben also bspw. \u0026lt;data source=\u0026quot;100*.a\u0026quot;/\u0026gt; - wird lediglich definiert, dass Werte in den Feldern, welche auf den Ausdruck 100*.a passen, ebenso wie die Feldnamen unverändert übernommen werden sollen.\nZudem gibt es für source zwei Variablen mit fixer Bedeutung:\n _id: Liest die ID des Datensatzes aus. _else: Prozessiert alle Literale, welche nicht durch eine andere Morph-Regel verarbeitet werden. Nützlich, wenn Literale nicht transformiert, aber auch nicht ausgefiltert werden sollen.  data nimmt aber noch ein zweites Attribut entgegen, name. Dadurch lassen sich Feldnamen umbenennen, während der Feldwert noch immer unverändert übernommen wird. Durch den Feldnamen _id wird die ID des Datensatzes überschrieben.\nDatenfelder mit Namen, die mit @ beginnen, werden speziell behandelt.\n Schliesslich lassen sich auf Feldwerte eine Reihe von Transformationen und Filter anwenden.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/funktionen/transformationen/",
	"title": "Transformationen",
	"tags": [],
	"description": "",
	"content": " compose Fügt dem Wert ein Prä- (prefix=) und/oder ein Suffix (postfix=) hinzu\nconstant Ersetzt Wert durch ein Literal (value=)\ntimestamp Ersetzt Wert durch aktuellen Zeitstempel\n format: Format des Zeitstempels gemäss java.text.SimpleDateFormat timezone: Zeitzone gemäss java.util.TimeZone (Standard: UTC) language: Gebietsschema gemäss java.util.Locale  substring Extrahiert Substring basierend auf Indizes (start=, end=)\nregexp Extrahiert einen Substring basierend auf einem regulären Ausdruck (match=). Rückwärtsreferenzen (capture groups) werden unterstützt, welche durch format=\u0026quot;${1..n}\u0026quot; wiederverwendet werden können. Syntax entspricht derjenigen von regulären Ausdrücken in Java\nreplace / setreplace Ersetzt einen passenden Substring (pattern=) durch einen anderen Wert (with=). Reguläre Ausdrücke analog zu Java werden unterstützt. Durch setreplace lässt sich eine ganze lokale Ersetzungstabelle definieren (\u0026lt;entry name=\u0026quot;ausdruck\u0026quot; value=\u0026quot;ersetzung\u0026quot;/\u0026gt;) oder mithilfe von map= eine solche referenzieren.\nFür weitere Informationen siehe Abschnitt \u0026ldquo;Nachschlagetabellen\u0026rdquo;\n lookup Analog zu setreplace, unterstützt aber nur statische Strings als Suchmuster. Mithilfe von in= kann alternativ auch eine Konkordanztabelle referenziert werden. default= definiert einen Standardwert, wenn Schlüssel nicht in Tabelle definiert ist.\nFür weitere Informationen siehe Abschnitt \u0026ldquo;Nachschlagetabellen\u0026rdquo;\n case Zu Gross- (upper) bzw. Kleinschreibung (lower) (to=). Nimmt optional ein Sprach-Tag entgegen (language=)\ntrim Schneidet Leerzeichen am Ende des Feldwertes ab\nnormalize-utf8 Normalisierung basierend auf UTF-8 (v.a. für Umlaute)\ndateformat Formatiert Datum\n inputformat: Format des Inputdatums gemäss java.text.SimpleDateFormat outputformat: Format des Ausgabedatums: FULL, LONG (Standard), MEDIUM oder SHORT (s. Beschreibung in java.text.DateFormat) era: Epoche: AUTO (Standard), AD oder BC removeLeadingZeros: Entferne führende Nulle (Standard: false) language: Gebietsschema gemäss java.util.Locale  split Teilt Feldwert basierend auf regulärem Ausdruck (delimiter=) in Substrings\nisbn Transformationen von ISBN-Nummern. Das Attribut to akzeptiert drei Werte: isbn10 für eine Umwandlung von ISBN13 zu ISBN10, isbn13 für das Umgekehrte und clean für eine Bereinigung der Nummer. Optional können zudem die Attribute verifyCheckDigit, standardmässig false, und errorString gesetzt werden.\nurlencode Enkodiert Wert als URL\nhtmlanchor Baut aus Wert einen HTML-Link. Umfasst drei Attribute: prefix (zwingend), postfix und title (optional)\nswitch-name-value Vertauscht Feldname und -wert\nscript Wert wird zur Transformation einer Javascript-Funktion (invoke=) in einer externen Datei (file=) übergeben\njava Wert wird zur Tranformation einer Java-Klasse (class=) übergeben. Werte aller weiteren Attribute werden einer gleichnamigen setter-Methode in der Klasse übergeben.\ncount Ersetzt Wert durch Anzahl der spezifizierten Felder im Datensatz\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/funktionen/filter/",
	"title": "Filter",
	"tags": [],
	"description": "",
	"content": " whitelist Filtert Werte basierend auf einer Whitelist (nur gelistete Werte werden weitergeleitet)\nFür weitere Informationen siehe Abschnitt \u0026ldquo;Nachschlagetabellen\u0026rdquo;\n blacklist Filtert Werte basierend auf einer Blacklist (gelistete Werte werden geblockt)\nFür weitere Informationen siehe Abschnitt \u0026ldquo;Nachschlagetabellen\u0026rdquo;\n equals / not-equals Literal wird nur dann weitergeleitet, wenn sein Wert gleich wie Wert in string= ist. Für not-equals gilt das Umgekehrte.\noccurrence Literal werden nur dann weitergeleitet, wenn sie mehr (moreThan) oder weniger oft (lessThan) als ein ein Wert (only=) vorkommen. Bsp.:\n\u0026lt;data source=\u0026#34;fieldA\u0026#34;\u0026gt; \u0026lt;occurrence only=\u0026#34;moreThan 4\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; unique Filtert doppelte Werte\n in: Gleiche Werte in Entität (entity) oder Datensatz (record, Standard) part: Teile des Literals, die gleich sein müssen: name, value (Standard) oder name-value  Ein Wert in part abweichend von value ist nur dann sinnvoll, wenn globs für den Feldnamen verwendet werden.\n buffer Hält Literale zurück, bis flush-Bedingung (flushWith=) erfüllt wird.\nFür weitere Informationen zu flushWith siehe Abschnitt \u0026ldquo;Ausgabesteuerung\u0026rdquo;.\n "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/funktionen/nachschlagetabellen/",
	"title": "Nachschlagetabellen",
	"tags": [],
	"description": "",
	"content": "Nachschlagetabellen dienen zur Filterung oder Ersetzung bestimmter Werte und werden so von den Funktionen whitelist und blacklist sowie setreplace und lookup verwendet. Sie können in Metamorph an verschiedenen Stellen definiert werden:\n Wird die Nachschlagetabelle nur an einer einzigen Stelle benötigt, macht es Sinn, sie direkt in der Funktion des betreffenden Literal selbst zu definieren. Dies geschieht mithilfe des Enumerierungstags entry, welches das obligatorische Attribut name= (Schlüssel) und das fakultative Attribut value= (Ersetzungswert). Die vier erwähnten Funktionen haben auch ein fakultatives Attribut map=. Mit diesem kann eine im gesamten Morph verfügbare Tabelle referenziert werden, die in einem vom \u0026lt;rules\u0026gt;-Abschnitt separierten Tag \u0026lt;maps\u0026gt; definiert wird:\n\u0026lt;maps\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry name=\u0026#34;schluessel1\u0026#34; value=\u0026#34;wert1\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;schluessel2\u0026#34; value=\u0026#34;wert2\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/maps\u0026gt; Schliesslich kann ebenfalls im Tag \u0026lt;maps\u0026gt; analog zu map eine Reihe von externen Quellen als Nachschlagetabelle angegeben werden:\n javamap: Java-Klasse, welche java.util.Map implementiert  name (obligatorisch): Name der Tabelle in Morph-Datei class (obligatorisch): Klassenname mit vollem Pfad Alle weiteren Attribute werden als Parameter der Klasse interpretiert  filemap: Textdatei, eine Zeile pro Schlüssel-Wert-Paar  name (obligatorisch): Name der Tabelle in Morph-Datei files (obligatorisch): Pfade zu Dateien mit Tabellen, getrennt durch Leerzeichen separator: Trennzeichen zwischen Schlüssel und Wert in Tabelle (Standard: \\t)  restmap: Abfrage einer REST-Schnittstelle  name (obligatorisch): Name der Tabelle in Morph-Datei url (obligatorisch): URL der REST-Schnittstelle  sqlmap: SQL-Abfrage  name (obligatorisch): Name der Tabelle in Morph-Datei host: Hostname (Standard: localhost) login (obligatorisch): Benutzername password (obligatorisch): Passwort database (obligatorisch): Name der Datenbank query (obligatorisch): Suchabfrage driver: Datenbanktreiber (Standard: com.mysql.jdbc.Driver)  jndisqlmap: SQL-Abfrage über die JNDI-Schnittstelle  name (obligatorisch): Name der Tabelle in Morph-Datei datasource (obligatorisch): Datenquelle query (obligatorisch): Suchabfrage    "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/collectors/",
	"title": "Collectors",
	"tags": [],
	"description": "",
	"content": "Mithilfe von collectors können Werte verschiedener Literalen aggregiert, gefiltert oder zusammengefasst werden. Fast alle von ihnen teilen sich zwei Eigenschaften:\n Der Zeitpunkt und die Art der Emission ihrer Werte ist steuerbar. Es ist möglich, sie nur dann auszuführen, wenn gewisse Bedingungen erfüllt sind.  Zudem ist es für die collectors combine, concat, equalsFilter, square, tuples, choose, range und group möglich, mittels \u0026lt;postprocess\u0026gt; Literal-Funktionen auf das Ergebnis anzuwenden. Beispiel:\n\u0026lt;combine name=\u0026#34;neu\u0026#34; value=\u0026#34;${nachname}, ${vorname}\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;feld1\u0026#34; name=\u0026#34;vorname\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;feld2\u0026#34; name=\u0026#34;nachname\u0026#34;/\u0026gt; \u0026lt;postprocess\u0026gt; \u0026lt;trim/\u0026gt; \u0026lt;case to=\u0026#34;upper\u0026#34;/\u0026gt; \u0026lt;/postprocess\u0026gt; \u0026lt;/combine\u0026gt;"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/collectors/uebersicht/",
	"title": "Übersicht collectors",
	"tags": [],
	"description": "",
	"content": " Folgend eine Liste der verfügbare collectors in Metamorph.\nDie Attribute flushWith, reset und sameEntity, welche für die meisten collectors verwendet werden können, werden im nächsten Abschnitt beschrieben.\n combine Fügt Literale gemäss einem Template zusammen. Nachfolgende Werte überschreiben vorangehenden Werte desselben Feldes.\n name (erforderlich): Name des neuen Feldes value (erforderlich): Template. Werte von Feldern können mit ${feldname} eingefügt werden  concat Fügt Literale in der angegebenen Reihenfolge in einem neuen Feld zusammen. Werte desselben Feldes werden konkateniert.\n name (erforderlich): Name des neuen Feldes delimiter: Trennzeichen zwischen einzelnen Literalen (Standard: \u0026quot;\u0026quot;) prefix: Präfix des neuen Feldes postfix: Suffix des neuen Feldes reverse: Fügt neue Literale am Anfang statt am Ende des neuen Feldes hinzu  entity Erstellt mit den definierten Literalen eine neue (Sub-)Entität. Nachfolgende Werte überschreiben vorangehende Werte desselben Feldes.\nname definiert den Namen der Entität, der alternativ auch mit dem entity-name-Element definiert werden kann. Wird weder name noch entity-name angegeben, wird ein leerer Name gesendet.\nsquare Fügt Literale zu allen möglichen nicht-permutierten Zweierkombinationen zusammen. Werte desselben Feldes werden nicht überschrieben.\n name (erforderlich): Name der neuen 2er-Tupel delimiter (erforderlich): Trennzeichen zwischen den ausgegebenen Literalen prefix: Präfix der 2er-Tupel postfix: Suffix der 2er-Tupel  tuples Gibt alle möglichen Kombinationen der definierten Literale aus.\n name (erforderlich): Name der neuen Literale separator: Trennzeichen zwischen den Literalen  group Gruppiert Literale und/oder collectors, normalerweise um ein gemeinsames Set an Funktionen auf sie anzuwenden.\n name: Neuer gemeinsamer Name value: Neuer gemeinsamer Wert  choose Sendet nur einen Literal aus einer Gruppe weiter (mit abnehmender Priorität).\n name: Name des neuen Literals value: Wert des neuen Literals  range Wertet zwei aufeinanderfolgende Literale als ganze Zahlen aus, die den Start- und Endpunkt einer Zahlenreihe definieren. Alle Zahlen dieser Reihe werden anschliessend als Literale ausgegeben.\n name (obligatorisch): Name der neuen Literale increment: Inkrement (Standard: 1)  equalsFilter Literale werden weitergeleitet, sofern alle Werte gleich sind.\n name (obligatorisch): Name des neuen Literals value (obligatorisch): Wert des neuen Literals  all, any \u0026amp; none Überprüfen, ob angegebenen Literale vorhanden sind. Geben standardmässig eine unbenannte (änderbar mit name=) Variable mit true als Wert (änderbar mit value=) aus, insofern die jeweilige Bedingung zutrifft:\n Bei all: Alle Literale sind im Datensatz vorhanden Bei any: Mindestens ein Literal ist im Datensatz vorhanden Bei none: Kein Literal ist im Datensatz vorhanden  Die Verwendung der drei Quantoren macht insbesondere Sinn im Zusammenhang mit if-Anweisungen.\n "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/collectors/ausgabesteuerung/",
	"title": "Ausgabesteuerung",
	"tags": [],
	"description": "",
	"content": " Wann und wie collectors die gesammelten Werte weiterschicken, kann mit Hilfe von drei Parametern definiert werden: flushWith, reset und sameEntity.\nflushWith definiert den Zeitpunkt, zu welchem der collector die Werte abschickt (flush). Dies kann entweder nach der Verarbeitung eines bestimmten Feldes (flushWith=\u0026quot;feldname\u0026quot;, Wildcards erlaubt) oder des gesamten Datensatzes sein (flushWith=\u0026quot;record\u0026quot;). Im Fall von combine, entity, equalsFilter sowie den Quantoren all, any und none werden die gesammelten Werte standardmässig weitergeleitet, sobald für jedes Feld ein Wert vorhanden ist.\nIn einem collector gesammelte Werte werden nicht weitergeleitet, wenn die flushWith-Bedingung nicht eintritt. Dies ist der Fall, wenn\n der angegbene Feldname nicht vorhanden ist oder bei Standardeinstellung von combine, entity, equalsFilter, all, any und none der collector nicht gefüllt werden kann collector bis Ende des Datensatzes nicht gefüllt wird  Enthält ein collector keine Werte bei Eintreffen der flushWith-Bedingung, passiert ebenfalls nichts.\n reset löscht alle gesammelten Werte, nachdem diese weitergeleitet wurden. Ist reset=\u0026quot;false\u0026quot;, werden also nach einem erstmaligen flush die aktuell im collector gespeicherten Werte bei jedem neu gesammelten Wert von Neuem abgeschickt!\nsameEntity leitet nur Werte weiter, die in derselben Literalgruppe (entity) gesammelt wurden. Ist die Literalgruppe fertig prozessiert, ohne dass für jedes Feld ein Wert vorhanden ist, werden die gespeicherten Werte weggeworfen. Der reset-Mechanismus wird anderseits bei sameEntity=\u0026quot;true\u0026quot; unabhängig von der Einstellung des reset-Paraemters ausgelöst, konnte die flush-Bedingung in einer Literalgruppe erfüllt werden.\nIm Fall von combine überschreiben neue ältere Werte des gleichen Datenfeldes.\n Standardeinstellungen für flushWith, reset und sameEntity    Collector flushWith reset sameEntity     combine wenn vollständig false false   concat record true false   entity wenn vollständig false false   squares record true entfällt   tuples record entfällt entfällt   group entfällt entfällt entfällt   choose record true false   range record false false   equalsFilter wenn vollständig false false   all wenn vollständig false false   any wenn vollständig false false   none wenn vollständig false false    "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/collectors/if-anweisungen/",
	"title": "if-Anweisungen",
	"tags": [],
	"description": "",
	"content": "Mithilfe von if-Anweisungen lässt sich steuern, ob ein collector Werte ausgibt oder nicht. Die Syntax sieht folgendermassen aus:\n\u0026lt;combine name=\u0026#34;ausgabe\u0026#34; value=\u0026#34;${a}+${b}\u0026#34;\u0026gt; \u0026lt;if\u0026gt; \u0026lt;data source=\u0026#34;feldA\u0026#34;\u0026gt; \u0026lt;equals string=\u0026#34;wertA\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;data source=\u0026#34;feldA\u0026#34; name=\u0026#34;a\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;feldB\u0026#34; name=\u0026#34;b\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt; Wenn der Wert im feldA tatsächlich wertA ist, dann wird das Ergebnis von ${a}+${b} ausgegeben, ansonsten nicht.\nIn der if-Anweisung lässt sich jede Filter-Funktion sowie die collectors all, any und none verwenden. Ein Beispiel mit all:\n\u0026lt;combine name=\u0026#34;ausgabe\u0026#34; value=\u0026#34;${a}+${b}\u0026#34;\u0026gt; \u0026lt;if\u0026gt; \u0026lt;all\u0026gt; \u0026lt;data source=\u0026#34;feldA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;feldB\u0026#34;/\u0026gt; \u0026lt;/all\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;data source=\u0026#34;feldA\u0026#34; name=\u0026#34;a\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;feldB\u0026#34; name=\u0026#34;b\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt; Wenn beide Literale einen Wert liefern, wird das Ergebnis von ${a}+${b} weitergeleitet.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/modularisierung/",
	"title": "Modularisierung",
	"tags": [],
	"description": "",
	"content": "Durch verschiedene Mechanismen lassen sich Metamorph-Definitionen wiederverwenden. Das folgende Kapitel stellt diese vor.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/modularisierung/rekursion/",
	"title": "Rekursion",
	"tags": [],
	"description": "",
	"content": "Normalerweise wird ein Literal direkt nach seiner Verarbeitung an das nächste command weitergeleitet. Es ist durch eine spezielle Syntax - ein führendes @ im Namen - allerdings möglich, Werte bis zum Prozessierungsende des Datensatzes im Cache zu halten:\n\u0026lt;data source=\u0026#34;eingabename\u0026#34; name=\u0026#34;@loop\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;@loop\u0026#34; name=\u0026#34;ausgabename\u0026#34;/\u0026gt; Dadurch lassen sich verschiedene Probleme lösen, so:\n Eine initiale Verarbeitung eines Literals lässt sich zentral definieren, die Ausgabe lässt sich an verschiedenen Orten im Morph wiederverwenden (beispielsweise in einem collector) Das Ergebnis eines collector, der vor Ende des Datensatzes \u0026ldquo;geflusht\u0026rdquo; werden muss, soll in einem anderen collector genutzt werden  Literale im Cache müssen bei jeder Wiederverwendung umbenannt werden, da sonst eine unendliche Schleife entsteht (aka ein StackOverflowError).\n Ein literales @ als erstes Zeichen eines Feldnamens ist möglich, wenn es durch einen vorangehenden \\ seiner speziellen Bedeutung \u0026ldquo;beraubt\u0026rdquo; wird (das \\ erscheint anschliessend nicht mehr im Namen). Das \\ ist nicht notwendig, wenn sich das betreffende Literal bzw. der betreffende collector innerhalb eines Eltern-collectors befindet (siehe dazu auch nächste Box).\n Literale bzw. collectors, welche innerhalb eines collectors in die Rekursion geschickt werden, werden gleichzeitig immer auch literal weitergeleitet (also bspw. als (\u0026quot;@feldname\u0026quot;: \u0026quot;feldwert\u0026quot;)). Da dieses Verhalten ist in der Regel nicht gewünscht, deshalb sollten Rekursionen grundsätzlich ausserhalb von Eltern-collectors definiert werden.\n Rekursion mit der @-Syntax kann das Problem nicht vollständig beheben, dass Literale in der Reihenfolge abgearbeitet werden, in der sie in das morph-command geschickt werden. So ist es beispielsweise meines Wissens nicht möglich, alle Werte mit demselben Feldnamen in einem collector wiederzuverwenden.\n "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/modularisierung/variablen/",
	"title": "Variablen",
	"tags": [],
	"description": "",
	"content": "Werte in Metamorph sind bis zu einem gewissen Grad dynamisierbar, indem sie als Parameter in der Flux-Datei oder über die Kommandozeile dem Programm übergeben werden. Dazu ist es notwendig, dass in der Flux-Datei das morph-command so angepasst wird, dass solche Parameter automatisch der Metamorph-Klasse übergeben werden:\nmorph(morphdatei, *)  Anschliessend können arbiträre Parameter in Flux definiert werden:\ndefault var1 = \u0026quot;wert1\u0026quot;; default var2 = \u0026quot;wert2\u0026quot;; // Flux-Commands...  default verhindert, dass bereits auf der Kommandozeile definierte Parameter überschrieben werden. Letzteres kann folgendermassen bewerkstelligt werden:\n./flux.sh fluxdatei var1=wert1 var2=wert2  In Metamorph werden so übergebene Parameter mittels $[variablenname] etc. ausgelesen, also beispielsweise:\n\u0026lt;data source=\u0026#34;_id\u0026#34; name=\u0026#34;feldA\u0026#34;\u0026gt; \u0026lt;constant value=\u0026#34;$[var1]\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Selbstredend können solche Variablen überall dort in Metamorph-Definitionen verwendet werden, wo auch Werte definiert werden können.\nSchliesslich lassen sich in Metamorph auch noch Standardwerte für Variablen definieren. Dies geschieht in einem vom \u0026lt;rules\u0026gt;-Element separierten \u0026lt;vars\u0026gt;-Tag:\n\u0026lt;vars\u0026gt; \u0026lt;var name=\u0026quot;var1\u0026quot; value=\u0026quot;wert1\u0026quot;/\u0026gt; \u0026lt;var name=\u0026quot;var2\u0026quot; value=\u0026quot;wert2\u0026quot;/\u0026gt; \u0026lt;/vars\u0026gt; \u0026lt;!-- \u0026lt;rules\u0026gt; ... --\u0026gt;  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/modularisierung/makros/",
	"title": "Makros",
	"tags": [],
	"description": "",
	"content": "Noch einen Schritt weiter als Variablen hinsichtlich der Wiederverwendbarkeit gehen Makros. Mit ihnen lassen sich eigentliche parametrisierbare Funktionen innerhalb der Morph-Datei definieren. Wie Variablen werden sie ausserhalb des \u0026lt;rules\u0026gt;-Elementes definiert, in diesem Fall im \u0026lt;macros\u0026gt;-Tag:\n\u0026lt;macros\u0026gt; \u0026lt;macro name=\u0026#34;eindeutiger_name\u0026#34;\u0026gt; \u0026lt;!-- Makro --\u0026gt; \u0026lt;/macro\u0026gt; \u0026lt;!-- Weitere Makros --\u0026gt; \u0026lt;/macros\u0026gt; \u0026lt;!-- \u0026lt;rules\u0026gt; ... --\u0026gt; Ein Makro muss zwingend mit einem eindeutigen Namen (name=) versehen werden, damit es später im \u0026lt;rules\u0026gt;-Block aufgerufen werden kann.\nMakros können einen beliebigen Block an Metamorph-Definitionen enthalten, also Literale mit ihren Funktionen, collectors sowie eine Kombination davon. Parameter werden wie Variablen in eckigen Klammern mit führendem Dollarzeichen geschrieben ($[param1]). Ein Beispiel eines einfachen Makros:\n\u0026lt;macro name=\u0026#34;makro1\u0026#34;\u0026gt; \u0026lt;concat delimiter=\u0026#34; \u0026#34; name=\u0026#34;$[ccName]\u0026#34; flushWith=\u0026#34;$[abschickenMit]\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;$[dsSource]\u0026#34; \u0026gt; \u0026lt;case to=\u0026#34;upper\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/concat\u0026gt; \u0026lt;/macro\u0026gt; Makros werden mit dem Element \u0026lt;call-macro\u0026gt; aufgerufen. call-macro umfasst ein obligatorisches Attribut, der Name des Makros (name=). Alle weiteren Attribute werden als Argumente des Makros interpretiert. Das obige Makro wird also beispielsweise folgendermassen aufgerufen\u0026gt;\n\u0026lt;combine name=\u0026#34;name\u0026#34; value=\u0026#34;${vorname} ${nachname}\u0026#34;\u0026gt; \u0026lt;call-macro name=\u0026#34;makro1\u0026#34; ccName=\u0026#34;vorname\u0026#34; dsName=\u0026#34;feldA\u0026#34; abschickenMit=\u0026#34;nachname\u0026#34; /\u0026gt; \u0026lt;data source=\u0026#34;feldB\u0026#34; name=\u0026#34;nachname\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt;"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/modularisierung/includes/",
	"title": "Includes",
	"tags": [],
	"description": "",
	"content": "Um Code-Blöcke nicht nur innerhalb einer Morph-Datei wiederzuverwenden, sondern auch zwischen Dateien zu teilen, können schliesslich sogenannte XML inclusions (oder kurz XInclude) verwendet werden. Solche inclusions sind möglich direkt im \u0026lt;metamorph\u0026gt;-Element, aber auch als Kind-Elemente von \u0026lt;rules\u0026gt;, \u0026lt;maps\u0026gt; und \u0026lt;macros\u0026gt;. Das heisst also, einfügbare Bausteine können Definitionen, Mappings, Makros oder der vollständige Inhalt einer Morph-Datei sein.\nBausteine und die sie verwendenden Morph-Definitionen sind zur Laufzeit eine einzige Einheit. Somit können beispielsweise Werte im Block in eine Rekursion geschickt werden und in der Hauptdatei wieder ausgelesen, oder in einem Block definierte Nachschlagetabellen in der Morph-Datei aufgerufen werden.\nAus diesem Grund haben Blöcke nie ein \u0026lt;metamorph\u0026gt;- und, werden sie direkt in einem der Kindelemente verwendet, auch kein \u0026lt;rules\u0026gt;-, \u0026lt;maps\u0026gt;- oder \u0026lt;macros\u0026gt;-Element.\n Eingefügt werden XML inclusions folgendermassen:\n\u0026lt;include href=\u0026#34;pfad/zum/einzufuegenden/block.xml\u0026#34; parse=\u0026#34;xml\u0026#34; xmlns=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34; /\u0026gt; Während der Block beispielsweise so aussehen kann:\n\u0026lt;!-- block.xml --\u0026gt; \u0026lt;?xml version=\u0026quot;1.1\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;map name=\u0026quot;hauptorte\u0026quot; xmlns=\u0026quot;http://www.culturegraph.org/metamorph\u0026quot;\u0026gt; \u0026lt;entry name=\u0026quot;Aargau\u0026quot; value=\u0026quot;Aarau\u0026quot;/\u0026gt; \u0026lt;entry name=\u0026quot;Appenzell Ausserrhoden\u0026quot; value=\u0026quot;Herisau\u0026quot;/\u0026gt; \u0026lt;entry name=\u0026quot;Appenzell Innerrhoden\u0026quot; value=\u0026quot;Appenzell\u0026quot;/\u0026gt; \u0026lt;entry name=\u0026quot;Basel-Landschaft\u0026quot; value=\u0026quot;Liestal\u0026quot;/\u0026gt; \u0026lt;entry name=\u0026quot;Basel-Stadt\u0026quot; value=\u0026quot;Basel\u0026quot; /\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/map\u0026gt;  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/kochbuch/",
	"title": "Kochbuch",
	"tags": [],
	"description": "",
	"content": "Komplementär zum ersten Teil werden im Kochbuch Lösungsstrategien für spezifische Probleme in Metamorph versammelt.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/kochbuch/literale-in-entitaeten-wiederverwenden/",
	"title": "Literale in Entitäten wiederverwenden",
	"tags": [],
	"description": "",
	"content": " Problem Ein Literal (litA) soll mit einem mehrfach vorhandenen weiteren Literal (litB) in einer Entität zusammenfügt werden, wobei für jedes litB eine Entität erstellt wird.\nEingabe:\n{litA: wertA, litB: wertB, litB: wertC}  Erwartete Ausabe:\n{entAB {litA: wertA, litB: wertB} entAB {litA: wertA, litB: wertC}}  Lösung \u0026lt;entity name=\u0026#34;entAB\u0026#34; flushWith=\u0026#34;litB\u0026#34; reset=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;combine name=\u0026#34;litA\u0026#34; value=\u0026#34;${litA}\u0026#34; flushWith=\u0026#34;litB\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34; name=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/entity\u0026gt; litA wird in einem combine-collector \u0026ldquo;gespeichert\u0026rdquo;, der in diesem Fall wie ein Cache benutzt werden kann. Wichtig ist, dass der collector zur gleichen Zeit weitergeleitet wird wie die ihn umgebende entity, da ansonsten der in ihm aggregierte Wert nur einmal (nämlich wenn er das erste Mal gefüllt ist) \u0026ldquo;geflusht\u0026rdquo; wird.\nAnaloges gilt für concat.\n Bemerkungen Andere, vermutlich naheliegendere Strategien funktionieren nicht\nDirektes Auslesen des Literals \u0026lt;entity name=\u0026#34;entAB\u0026#34; flushWith=\u0026#34;litB\u0026#34; reset=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34; name=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/entity\u0026gt; Ausgabe:\n{entAB {litA: wertA, litB: wertB} entAB {litB: wertC}}  Da das Feld litA vor litB ausgelesen und im entity-Block nach der Verarbeitung des ersten litB geflusht wird, steht es zum Zeitpunkt des zweiten litB nicht mehr zur Verfügung.\nEntität nicht zurücksetzen \u0026lt;entity name=\u0026#34;entAB\u0026#34; flushWith=\u0026#34;litB\u0026#34; reset=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;combine name=\u0026#34;litA\u0026#34; value=\u0026#34;${litA}\u0026#34; flushWith=\u0026#34;litB\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34; name=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/entity\u0026gt; Ausgabe:\n{entAB {litA: wertA, litB: wertB} entAB {litA: wertA, litB: wertB, litB: wertC}}  Nicht möglich, da so alle Werte in entity gesammelt werden. Allerdings würde diese Strategie beispielsweise für combine funktionieren, da in diesem Fall Werte mit gleichem Feldnamen überschrieben werden.\nRekursives Zugreifen auf litA \u0026lt;data source=\u0026#34;litA\u0026#34; name=\u0026#34;@loop\u0026#34;/\u0026gt; \u0026lt;entity name=\u0026#34;entAB\u0026#34; flushWith=\u0026#34;litB\u0026#34; reset=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;@loop\u0026#34; name=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34; name=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/entity\u0026gt; Ausgabe:\n{entAB {litA: wertA, litB: wertB} entAB {litB: wertC}}  Zwar ist der Wert von litA über die ganze restliche Prozessierungszeit des Records im Cache gespeichert, doch kann pro Zugriffsort nur einmal über ihn iteriert werden.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/anhang/",
	"title": "Anhang",
	"tags": [],
	"description": "",
	"content": " Besprechung von Morph-Definitionen in linked-swissbib Metafacture / Metamorph: Ressourcen im Internet Glossar Versionsgeschichte Dokumentation  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/anhang/lsb-morphs/",
	"title": "Morphs in linked-swissbib",
	"tags": [],
	"description": "",
	"content": " documentMorph.xml Erstellt Metadaten der Aufnahme. Pro bibliographicRecord-Ressource sollte auch eine document-Ressource vorhanden sein.\nenrichedMorph.xml Verarbeitet Datensätze im NTriples-Format und transformiert sie zu JSON-LD. Datensatz-Typen sind \u0026ldquo;Organisationen\u0026rdquo; (siehe Anmerkungen dazu im Abschnitt \u0026ldquo;organisationMorph.xml\u0026rdquo;) und \u0026ldquo;Personen\u0026rdquo;. Aufgrund der Syntax-Spezifika von NTriples sowie für die Normalisierung der Inputdaten, welche aus heterogenen Quellen stammen (DBPedia, VIAF, vorverarbeitete Swissbib-Daten), müssen die meisten Werte modifiziert werden. Die drei wichtigsten Fälle, die jeweils in einem \u0026lt;macro\u0026gt;-Element definiert werden:\n Makro year: Jahresangaben sind immer nur auf das (vierstellige) Jahr genau, und nicht etwa in der Form yyyy-mm-dd. Makro uri: DBPedia-Links sollen immer zu https://-Links umgewandelt werden Makro language-tag: Das Sprach-Tag, welches in NTriples mit einem @-Trennzeichen an das Literal angefügt wird, wird abgetrennt und in ein eigenes Literal (lang überführt).  Personen und \u0026ldquo;Organsationen\u0026rdquo; haben verschiedene JSON-LD-Kontexte. Daher gibt es zwei \u0026lt;combine\u0026gt;-Blöcke zur Erstellung des jeweiligen Kontextes, wo überprüft wird, ob es sich um einen Datensatz vom Typ Person oder Organization handelt. Je nach dem werden im betreffenden Kontext-Block die Daten weitergeleitet oder nicht.\nitemMorph.xml Erstellt Exemplardaten primär basierend auf dem nicht-kanonischen MARC-Feld 949. Hinweise:\n Die ID ist eine Kombination aus einem konstanten Präfix - https://data.swissbib.ch/item/ -, dem Namen des Verbundes (Information aus Unterfeld 949??.B) sowie einem eindeutigen Hash-Wert, der auf verschiedenen Werten aus den 949er-Unterfeldern beruht. Der Hashwert wird mit der Klasse ItemHash erstellt. In einer bibliographischen Aufnahme können selbstverständlich Daten zu mehreren Exemplaren vorhanden sein. Dazu wird ein spezielles Verfahren genutzt, welches Entitäten erstellt und in einem weiteren command diese zu eigenen records umwandelt. Für Details siehe Hinweis-Block unten. Der \u0026lt;combine\u0026gt;-Block, wo der Hashwert generiert wird, befindet sich ausserhalb des \u0026lt;entity\u0026gt;-Blocks. Grund dafür ist das spezielle Verhalten von Rekursionen, welche innerhalb von collectors initialisiert werden. Für Details siehe Hinweise im entsprechenden Kapitel. In einem weiteren \u0026lt;combine\u0026gt;-Element, foaf:page, wird ein Link zum Katalogisat im jeweiligen Katalog erstellt. Dazu werden verschiedene Werte an eine weitere Klasse zur Verarbeitung geschickt, ItemLink.  Ein wiederholt genutzte Methode für Extraktion von mehreren eigenständigen Ressourcen aus einer einzigen bibliographischen (Eingabe-)Ressource ist die Erstellung von Entitäten (entity) in der betreffenden Morph-Datei. Dieser entity-Block umfasst alle Literale, welche für die jeweilige Zielressource benötigt werden. Nach dem morph-command folgt entity-splitter, das einzelne Entitäten eines Records einliest, diese aber als eigentständige Records wieder ausgibt. Mithilfe des Parameters entityBoundary lässt sich zudem für mehrfach geschachtelte Entitäten einstellen, ab welcher Stufe die Entitäten Records werden sollen.\n organisationMorph.xml Erstellt \u0026ldquo;Organisations\u0026rdquo;-Entitäten (Organisationen, Institutionen, Kongresse etc.) auf Basis von Marc-Feld 110, 111, 710 oder 711.\n Um solche Entitäten zu erstellen, wird der entity-collector verwendet. Solche Unter-Entitäten werden dann im nächsten Metafacture-Schritt zu eigenen Records \u0026ldquo;aufgewertet\u0026rdquo;. Für Details siehe Hinweis-Block in Abschnitt \u0026ldquo;itemMorph.xml\u0026rdquo;. Da der Identifier analog zu resourceMorph.xml und organisationMorph.xml mit dem Hash-Mechanismus erstellt wird, ist es für Entitäten aus den Feldern 110 und 111 zwingend, dass sie erst mit Unterfeld 245*.a weitergeleitet werden. Damit eine Entität für Feld 110 oder 111 nicht \u0026ldquo;aus Versehen\u0026rdquo; weitergeleitet wird (sprich: es gibt in der Ressource gar kein entsprechendes Feld), ist es wichtig, dass alle Bestandteile des collectors nur getriggert werden, wenn tatsächlich ein entsprechendes (Unter-)Feld vorhanden ist. Denn wie im Kapitel \u0026ldquo;Ausgabesteuerung\u0026rdquo; beschrieben, wird ein collector auch bei einem expliziten flushWith nur weitergeleitet, wenn er nicht leer ist. Entsprechend abgesichert wird an verschiedenen Stellen: Alle Literale (auch Konstanten) haben als Source 110??, 111?? oder eines ihrer Unterfelder; dasselbe gilt für Literale in Kind-collectors; schliesslich wird bei der Hashwert-Generierung in authorHash110 und authorHash111 mit einer if-Anweisung getetest, ob entsprechende Unterfelder vorhanden sind - ansonsten wird kein Hash (auch kein NO_HASH!) generiert. Dieselbe Vorsichtsmassnahme ist für Entitäten der Felder 710 und 711 nicht notwendig, da sie mit dem demselben Feld getriggert werden, aus dem sie ihre Werte beziehen.  personMorph.xml Erstellt Personen-Entitäten auf Basis von MARC-Feld 100 (1. Indikator 0 oder 1) oder 700 (1. Indikator dito). Der grundsätzlich Mechanismus ist derselbe wie bei itemMorph.xml und organisationMorph.xml: Literale werden pro relevantem Feld in entity-Blöcke zusammengefasst und anschliessend zu eigenständigen Ressourcen umgewandelt (für genauere Erläuterungen dazu s. Info-Box im Abschnitt zu itemMorph.xml). Zudem sind dieselben \u0026ldquo;Sicherheitsmassnahmen\u0026rdquo; wie bei organisationMorph.xml für Feld 100-Fälle implementiert, um ein unabsichtliches Weiterleiten einer Entität ohne Werte aus dem entsprechenden Feld zu verhindern.\nresourceMorph.xml Erstellt das eigentliche Katalogisat und linkt (bzw. wird verlinkt durch) die Ressourcen Person, Organisation, Document, Item sowie die separat erstellte Work.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/anhang/ressourcen/",
	"title": "Ressourcen",
	"tags": [],
	"description": "",
	"content": " Praxis  Metafacture-Code auf Github Metafacture-Wiki Metamorph-Schema Alte Metafacture-Organisation auf Github Metafacture: Beispiele Metafacture Java Examples Docker Image für Metafacture Standalone (experimentell)  Theorie  Analysis of library metadata with Metafacture (Vortrag Christoph Böhme) Metamorph: A Transformation Language for Semi-structured Data Das Metamorph-Datenmodell  linked-swissbib  linked-swissbib-Organisation auf Github, insbesondere:  mfWorkflows (Morph-Definitionen) swissbib-metafacture-commands (linked-swissbib Plugin für Metafacture)  Artikel-Reihe zu linked-swissbib:  Swissbib data goes linked 1: Metadatentransformation, Modellierung, Indexierung Swissbib data goes linked 2: Verlinkung und Anreicherung Swissbib data goes linked 3: Präsentation der angereicherten Daten Swissbib data goes linked Teil 4: Hydra Web API for smarter clients   "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/anhang/versionsgeschichte/",
	"title": "Versionsgeschichte",
	"tags": [],
	"description": "",
	"content": " 0.09 (16.08.18) Rohfassung\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/",
	"title": "Einführung",
	"tags": [],
	"description": "",
	"content": " Dieses README beinhaltet Informationen zu Funktionen und collectors in Metamorph sowie eine Sammlung von Ansätzen (\u0026ldquo;Hacks\u0026rdquo;), wie komplexere Transformationsworkflows in Metamorph bewerkstelligt werden können.\nGenerelle Hinweise zu Metamorph-Dateien Metamorph-Dateien sind im XML-Format. Jede Metamorph-Regel muss innerhalb des \u0026lt;metamorph\u0026gt;-Elementes abgelegt werden:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;metamorph xmlns=\u0026#34;http://www.culturegraph.org/metamorph\u0026#34; version=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;!-- Hier kommen die Definitionen hin --\u0026gt; \u0026lt;/metamorph\u0026gt; Direkt unterhalb des \u0026lt;metamorph\u0026gt;-Elementes können folgende Elemente definiert werden:\n \u0026lt;include\u0026gt;: Einbinden von externen Definitionen \u0026lt;macros\u0026gt;: Dateiweite Funktionen \u0026lt;maps\u0026gt;: Liste von Nachschlagetabellen \u0026lt;meta\u0026gt;: Metadaten der Datei: Gültige Kindelemente sind \u0026lt;name\u0026gt; und \u0026lt;annotation\u0026gt; \u0026lt;rules\u0026gt;: Tranformations- und Filterregeln (die den Hauptteil dieser Dokumentation ausmachen) \u0026lt;vars\u0026gt;: Dateiweite Konstanten  Metamorph selbst hat zwei eigene Attribute:\n version: Die Version des Metamorph-Schemas entityMarker: Trennzeichen zwischen Entität und einem Literal (Standard: .)  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]