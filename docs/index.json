[
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/einfuehrung/",
	"title": "Einführung",
	"tags": [],
	"description": "",
	"content": " Dieser Teil soll einen generellen Überblick über Metamorph verschaffen sowie allgemeine Hinweise zur Lektüre der Dokumentation geben.\nInhalt  Metamorph - eine Übersicht Hinweise zu Codebeispielen  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/einfuehrung/metamorph/",
	"title": "Metamorph",
	"tags": [],
	"description": "",
	"content": " Innerhalb von Metafacture nimmt Metamorph die Rolle einer DSL (\u0026ldquo;Domain-specific language\u0026rdquo;) ein, mit welcher einzelne Schlüssel-Wert-Paare (sogenannte Literale) von Datensätzen transformiert oder gefiltert werden. Dafür werden Regeln (\u0026ldquo;Metamorph\u0026rdquo;- oder kurz \u0026ldquo;Morph-Definition\u0026rdquo;) festgelegt, welche anschliessend durch Metafacture auf einzelne Felder (identifiert durch Schlüssel-/Feldnamen) angewendet werden. Diese Regeln sind als XML-Elemente formuliert, und daher sind auch Metamorph-Dateien \u0026ldquo;normale\u0026rdquo; XML-Dateien.\nEinen umfassenden Überblick über die erlaubten Elemente gibt das Metamorph-Schema.\n XML-Struktur Jede Morph-Definition muss innerhalb des \u0026lt;metamorph\u0026gt;-Elementes abgelegt werden:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;metamorph xmlns=\u0026#34;http://www.culturegraph.org/metamorph\u0026#34; version=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;!-- Hier kommen die Definitionen hin --\u0026gt; \u0026lt;/metamorph\u0026gt; Direkt unterhalb des \u0026lt;metamorph\u0026gt;-Elementes können folgende Elemente definiert werden:\n \u0026lt;include\u0026gt;: Einbinden von externen Definitionen \u0026lt;macros\u0026gt;: Dateiweite Funktionen \u0026lt;maps\u0026gt;: Liste von Nachschlagetabellen \u0026lt;meta\u0026gt;: Metadaten der Datei: Gültige Kindelemente sind \u0026lt;name\u0026gt; und \u0026lt;annotation\u0026gt; \u0026lt;rules\u0026gt;: Tranformations- und Filterregeln (die den Hauptteil dieser Dokumentation ausmachen) \u0026lt;vars\u0026gt;: Dateiweite Konstanten  Metamorph selbst hat zwei eigene Attribute:\n version: Die Version des Metamorph-Schemas entityMarker: Trennzeichen zwischen Entität und einem Literal  Verwendung von Metamorph-Definitionen in Metafacture In Metafacture werden Workflows mithilfe von sogenannten Flux\u0026rdquo;-Skripten festgelegt. Flux besteht aus einer Reihe von Befehlen (commands), die jeweils einen Teil des Workflows beschreiben (bspw. das Öffnen einer Datei oder das Dekodieren eines Formates).\nEin Überblick der zur Verfügung stehenden Flux-Befehle ist hier zu finden.\n Um eine Morph-Definition in einem solchen Flux-Skript zu verwenden, wird der Befehl morph('/pfad/zur/morph/datei') benutzt.\nDaneben gibt es noch einen zweiten Befehl, der ebenfalls mit Morph-Definitionen arbeitet: filter('/pfad/zur/morph/datei'). In einer solchen Morph-Datei werden Regeln definiert - meistens das Vorhandensein einzelner Felder -, welche von einem Datensatz erfüllt werden müssen, damit er im Workflow weitergeleitet wird. Vielfach macht es Sinn, einen solchen Filter mit einer nachfolgenden Transformation zu kombinieren, so beispielsweise um zu vermeiden, dass Datensätze in die Transformation geschickt werden, welche nicht \u0026ldquo;regelkonform\u0026rdquo; sind und daher zu unerwarteten Resultaten führen können.\nEin Beispiel für einen solchen Fall ist die \u0026ldquo;baseline\u0026rdquo;, ein Datenworkflow in linked-swissbib, wo die Existenz eines gewissen Feldes - MARC-Feld 245*.a - Voraussetzung dafür ist, dass weitere Felder eines Datensatzes im Morph-Schritt korrekt zusammengefügt werden.\n "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/einfuehrung/hinweise-codebeispiele/",
	"title": "Hinweise zu Codebeispielen",
	"tags": [],
	"description": "",
	"content": " Formeta In der Dokumentation finden sich immer wieder Codebeispiele. Ein- und Ausgaben werden dabei im sog. Formeta-Format dargestellt. Formeta hat lediglich zwei Bausteine: Literale (Schlüssel-Wert-Paare) und Entitäten (Objekte, die Literale oder weitere Entitäten enthalten). Weiter gelten folgende Regeln:\n Jeder Datensatz ist eine Entität Literale werden in der Form schlüssel: wert geschrieben und mit Kommata (,) voneinander getrennt Entitäten werden in der Form schlüssel { \u0026lt;objektinhalt\u0026gt; } geschrieben und können optional mit Kommata voneinander getrennt werden (Achtung: Zwischen schlüssel und { hat es im Unterschied zu JSON keinen Doppelpunkt!) Mit \\ können Zeichen mit spezieller Bedeutung maskiert werden: Das sind neben den Trennzeichen :, ,, { und } ' (einfaches Anführungszeichen) und das Maskierungszeichen \\ selbst. :. Anderseits haben \\n (Zeilenumbruch) und \\r (Wagenrücklauf) spezielle Bedeutung :, ,, { und } müssen in Werten nicht maskiert werden, wenn der Text in einfachen Anführungszeichen steht Leerzeichen, Tabulatoren, Zeilenumbrüche und Wagenrückläufe können optional zur besseren Lesbarkeit eingesetzt werden  Ein Beispiel:\n{ kanton1 { name: Appenzell Ausserrhoden, hauptort: 'Herisau, Trogen', einwohnerzahl: 55\\'000 }, kanton2 { name: Appenzell Innerrhoden, hauptort: 'Appenzell', einige berge: { hoher berg: säntis, und: schäfler } }  Dasselbe Beispiel in kompakter Schreibweise ohne Leerzeichen, Zeilenumbrüche und optionalen Kommata:\n{kanton{name:Appenzell Ausserrhoden,hauptort:Herisau\\, Trogen,einwohnerzahl:55\\'000}kanton2{name:Appenzell Innerrhoden,hauptort:Appenzell,einige berge{hoher berg:säntis,und:schäfler}}}  Metafacture Runner Um die Beispiele selber durchspielen zu können, muss der sog. Metafacture runner (eine ausführbare Instanz von Metafacture) installiert werden. Dazu die aktuelle Metafacture-Distribution herunterladen und entpacken. Weitere Hinweise dazu finden sich auf der Website von Metafacture. Zudem ist eine sog. Flux-Datei notwendig, in der der Transformationsworkflow definiert wird. Eine minimale Flux-Datei, in der das obige Beispiel transformiert wird, ist folgendermassen aufgebaut:\nFLUX_DIR + \u0026quot;eingabe.formeta\u0026quot;| // Pfad zur Eingabedatei; FLUX_DIR enthält den Pfad zur Flux-Datei open-file| // Öffne Datei as-formeta-records| // Prozessiere Dateitext als Formeta decode-formeta| // Dekodiere Formeta morph(FLUX_DIR + \u0026quot;morph.xml\u0026quot;)| // Wende Transformationsregeln an (in morph.xml definiert) encode-formeta| // Serialisiere als Formeta write(\u0026quot;stdout\u0026quot;); // Gib Resultat auf Kommandozeile aus  Nachdem Metafacture runner installiert und die Flux- sowie die Eingabedatei erstellt sind, ins Verzeichnis der Flux-Datei wechseln und auf der Kommandozeile folgendes eingeben:\n/pfad/zu/metafacture/runner/flux.sh flux.datei Docker-Image Anstatt Metafacture runner zu installieren, kann auch das entsprechende Docker-Image verwendet werden. Dazu muss Docker lokal installiert werden. Anschliessend über Kommandozeile ins Verzeichnis wechseln, wo sich die Flux- und die Eingabedatei befinden, und eingeben:\ndocker run -v `pwd`:/mfwf:ro sschuepbach/metafacture-runner:latest flux.datei Wird das Docker-Image zum ersten Mal ausgeführt, dauert der Prozess etwas länger, da zuerst das entsprechende Image heruntergeladen werden muss.\n "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/literale/",
	"title": "Literale",
	"tags": [],
	"description": "",
	"content": " Dieser Teil beschäftigt sich mit den atomaren Einheiten, welche in Metamorph verarbeitet werden, Schlüssel-Wert-Paare oder Literale genannt.\nInhalt  Grundlagen Literale transformieren Literale filtern Literalwerte mappen  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/literale/datenfelder/",
	"title": "Werte auslesen",
	"tags": [],
	"description": "",
	"content": "Werte einzelner Datenfelder können mit der Funktion data ausgelesen werden. In ihrer einfachsten Form hat data ein Attribut, source, welches dem Namen des auszulesenden Feldes entspricht. Dabei können auch Wildcards verwendet werden, so ? für ein beliebiges Zeichen und * für Sequenz arbiträrer Zeichen mit Länge 0-n. In dieser einfachsten Form - ausgeschrieben also bspw. \u0026lt;data source=\u0026quot;100*.a\u0026quot;/\u0026gt; - wird lediglich definiert, dass Werte in den Feldern, welche auf den Ausdruck 100*.a passen, ebenso wie die Feldnamen unverändert übernommen werden sollen.\nZudem gibt es für source zwei Variablen mit fixer Bedeutung:\n _id: Liest die ID des Datensatzes aus. _else: Prozessiert alle Literale, welche nicht durch eine andere Morph-Regel verarbeitet werden. Nützlich, wenn Literale nicht transformiert, aber auch nicht ausgefiltert werden sollen.  data nimmt aber noch ein zweites Attribut entgegen, name. Dadurch lassen sich Feldnamen umbenennen, während der Feldwert noch immer unverändert übernommen wird. Durch den Feldnamen _id wird die ID des Datensatzes überschrieben.\nDatenfelder mit Namen, die mit @ beginnen, werden speziell behandelt.\n Schliesslich lassen sich auf Feldwerte eine Reihe von Transformationen und Filter anwenden.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/literale/transformationen/",
	"title": "Transformationen",
	"tags": [],
	"description": "",
	"content": " Dieses Kapitel gibt eine Übersicht über Literalfunktionen, welche Literalwerte ändern oder ersetzen. Wie die im nächsten Kapitel besprochenen Filterfunktionen werden sie innerhalb des \u0026lt;data\u0026gt;-Elementes eingefügt und können, wo sinnvoll, beliebig miteinander kombiniert werden. Dabei wird der Wert von oben nach unten von der einen zur nächsten Funktion durchgereicht. Ein Beispiel:\n\u0026lt;data source=\u0026#34;litA\u0026#34; name=\u0026#34;gruss\u0026#34;\u0026gt; \u0026lt;trim/\u0026gt; \u0026lt;whitelist\u0026gt; \u0026lt;entry name=\u0026#34;hallo\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;grüezi\u0026#34;/\u0026gt; \u0026lt;/whitelist\u0026gt; \u0026lt;case to=\u0026#34;upper\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; compose   compose fügt dem Wert ein Prä- (prefix=) und/oder ein Suffix (postfix=) hinzu\n  Beispiel   Eingabe\n{litA: zeug}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;compose prefix=\u0026#34;be\u0026#34; postfix=\u0026#34;ung\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA: bezeugung}   \n  constant   constant ersetzt Wert durch ein Literal (value=)\n  Beispiel   Eingabe\n{litA: sinnlos}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;constant value=\u0026#34;sinnvoll\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA: sinnvoll}   \n  timestamp   timestamp ersetzt Wert durch aktuellen Zeitstempel\n format: Format des Zeitstempels gemäss java.text.SimpleDateFormat timezone: Zeitzone gemäss java.util.TimeZone (Standard: UTC) language: Gebietsschema gemäss java.util.Locale    Beispiel   Eingabe\n{}  Morph-Definition\n\u0026lt;data source=\u0026#34;_id\u0026#34; name=\u0026#34;zeitstempel\u0026#34;\u0026gt; \u0026lt;timestamp format=\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34; timezone=\u0026#34;GMT+02:00\u0026#34; language=\u0026#34;de\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{zeitstempel: 2018-08-24 17\\:59\\:18}   \n  substring   substring extrahiert Substring basierend auf Indizes (start=, end=)\n  Beispiel   Eingabe\n{litA: bezeugung}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;substring start=\u0026#34;2\u0026#34; end=\u0026#34;6\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA: zeug}   \n  regexp   regexp extrahiert einen Substring basierend auf einem regulären Ausdruck (match=). Rückwärtsreferenzen (capture groups) werden unterstützt, welche durch format=\u0026quot;${1..n}\u0026quot; wiederverwendet werden können. Syntax entspricht derjenigen von regulären Ausdrücken in Java.\n  Beispiel   Eingabe\n{litA: eins zwei drei}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;regexp match=\u0026#34;\\S+ (\\S+) \\S+\u0026#34; format=\u0026#34;${1} bücher\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA: zwei bücher}   \n  replace / setreplace   replace /  setreplace ersetzt einen passenden Substring (pattern=) durch einen anderen Wert (with=). Java-konforme reguläre Ausdrücke werden unterstützt. Durch setreplace lässt sich eine ganze lokale Ersetzungstabelle definieren (\u0026lt;entry name=\u0026quot;ausdruck\u0026quot; value=\u0026quot;ersetzung\u0026quot;/\u0026gt;) oder mithilfe von map= eine solche referenzieren.\nFür weitere Informationen siehe Abschnitt \u0026ldquo;Nachschlagetabellen\u0026rdquo;\n   Beispiel   Eingabe\n{litA: eins, litA: zwei, litA: drei, litA: vier}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34; name=\u0026#34;zahl\u0026#34;\u0026gt; \u0026lt;setreplace\u0026gt; \u0026lt;entry name=\u0026#34;eins\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;zwei\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;drei\u0026#34; value=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;vier\u0026#34; value=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;/setreplace\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA: 1, litA: 2, litA: 3, litA: 4}   \n  lookup   lookup ist analog zu setreplace, unterstützt aber nur statische Strings als Suchmuster. Mithilfe von in= kann alternativ auch eine Konkordanztabelle referenziert werden. default= definiert einen Standardwert, wenn Schlüssel nicht in Tabelle definiert ist.\nFür weitere Informationen siehe Abschnitt \u0026ldquo;Nachschlagetabellen\u0026rdquo;\n   Beispiel   Eingabe\n{kanton: Waadt, kanton: Wallis, kanton: Jura, kanton: Genf}  Morph-Definition\n\u0026lt;data source=\u0026#34;kanton\u0026#34; name=\u0026#34;hauptort\u0026#34;\u0026gt; \u0026lt;lookup default=\u0026#34;nicht bekannt\u0026#34;\u0026gt; \u0026lt;entry name=\u0026#34;Wallis\u0026#34; value=\u0026#34;Sion\u0026#34; \u0026lt;entry name=\u0026#34;Jura\u0026#34; value=\u0026#34;Delémont\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;Waadt\u0026#34; value=\u0026#34;Lausanne\u0026#34;/\u0026gt; \u0026lt;/lookup\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{hauptort: Lausanne, hauptort: Sion, hauptort: Delémont, hauptort: nicht bekannt}   \n  case   case wandelt Wert in Gross- (upper) bzw. Kleinbuchstaben (lower) (to=) um. Nimmt optional ein Sprach-Tag entgegen (language=)\n  Beispiel   Eingabe\n{buch: kitabı}  Morph-Definition\n\u0026lt;data source=\u0026#34;buch\u0026#34;\u0026gt; \u0026lt;case to=\u0026#34;upper\u0026#34; language=\u0026#34;tr\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{buch: KİTABI}   \n  trim   trim schneidet Leerzeichen am Ende des Feldwertes ab\n  Beispiel   Eingabe\n{litA: 'luftig '}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;trim /\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA: luftig}   \n  normalize-utf8   normalize-utf8 normalisiert Zeichen in kanonische Form, bspw. ein ä, das aus dem Diakrit ¨ + a gebildet wurde, zu ä. Für Details siehe hier.\n  Beispiel   Eingabe\n{litA: ä }  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;normalize-utf8 /\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA: ä}   \n  dateformat   dateformat formatiert Datum\n inputformat: Format des Inputdatums gemäss java.text.SimpleDateFormat outputformat: Format des Ausgabedatums: FULL, LONG (Standard), MEDIUM oder SHORT (s. Beschreibung in java.text.DateFormat) era: Epoche: AUTO (Standard), AD oder BC removeLeadingZeros: Entferne führende Nulle (Standard: false) language: Gebietsschema gemäss java.util.Locale  removeLeadingZeros=\u0026quot;true\u0026quot; entfernte in unseren Tests fälschlicherweise auch Nulle in vierstelligen Jahreszahlen, das Resultat war also bspw. 218 anstelle von 2018!\n   Beispiel   Eingabe\n{heute: 2018-08-26 }  Morph-Definition\n\u0026lt;data source=\u0026#34;heute\u0026#34;\u0026gt; \u0026lt;dateformat inputformat=\u0026#34;yyyy-MM-dd\u0026#34; outputformat=\u0026#34;FULL\u0026#34; era=\u0026#34;AD\u0026#34; removeLeadingZeros=\u0026#34;false\u0026#34; language=\u0026#34;de\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{heute:Sonntag\\, 26. August 2018}   \n  split   split teilt Feldwert basierend auf regulärem Ausdruck (delimiter=) in Substrings\n  Beispiel   Eingabe\n{heute: 2018-08-26 }  Morph-Definition\n\u0026lt;data source=\u0026#34;heute\u0026#34; name=\u0026#34;monat\u0026#34;\u0026gt; \u0026lt;split delimiter=\u0026#34;-\u0026#34;/\u0026gt; \u0026lt;occurrence only=\u0026#34;moreThan 1\u0026#34;/\u0026gt; \u0026lt;occurrence only=\u0026#34;lessThan 2\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; occurrence ist ein Filter, welche nur Werte weiterleitet, die bis zu oder ab einem bestimmten Index in einer Liste von Werten vorkommen.\n Ausgabe\n{monat: 10}  \n\n  isbn   isbn transformiert ISBN-Nummern. Das Attribut to akzeptiert drei Werte: isbn10 für eine Umwandlung von ISBN13 zu ISBN10, isbn13 für das Umgekehrte und clean für eine Bereinigung der Nummer. Optional können zudem die Attribute verifyCheckDigit, standardmässig false, und errorString gesetzt werden.\n  Beispiel   Eingabe\n{isbn: 978-3-89401-810}  Morph-Definition\n\u0026lt;data source=\u0026#34;isbn\u0026#34;\u0026gt; \u0026lt;isbn to=\u0026#34;isbn10\u0026#34; verifyCheckDigit=\u0026#34;true\u0026#34; errorString=\u0026#34;ungültig\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{isbn:ungültig}   \n  urlencode   urlencode enkodiert Wert als URL\n  Beispiel   Eingabe\n{suchwert: gelebtes leben}  Morph-Definition\n\u0026lt;data source=\u0026#34;suchwert\u0026#34;\u0026gt; \u0026lt;urlencode /\u0026gt; \u0026lt;compose prefix=\u0026#34;https://swissbib.ch/Search/Results?lookfor=\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{suchwert:https\\://swissbib.ch/Search/Results?lookfor=gelebtes+leben}   \n  htmlanchor   htmlanchor baut aus Wert einen HTML-Link. Umfasst drei Attribute: prefix (zwingend), postfix und title (optional)\n  Beispiel   Eingabe\n{artikel: mein interessanter beitrag}  Morph-Definition\n\u0026lt;data source=\u0026#34;anker\u0026#34;\u0026gt; \u0026lt;urlencode /\u0026gt; \u0026lt;htmlanchor prefix=\u0026#34;https://example.com/\u0026#34; title=\u0026#34;Mein interessanter Beitrag\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{anker:\u0026lt;a href=\u0026quot;https\\://example.com/mein+interessanter+beitrag\u0026quot;\u0026gt;Mein interessanter Beitrag\u0026lt;/a\u0026gt;}   \n  switch-name-value   switch-name-value vertauscht Feldname und -wert\n  Beispiel   Eingabe\n{litA: wertA}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;switch-name-value/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{wertA: litA}   \n  script   script übergibt Wert zur Transformation an eine Javascript-Funktion (invoke=) in einer externen Datei (file=)\n  Beispiel   Eingabe\n{palindrom: Regallager}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;script file=\u0026#34;stringutils.js\u0026#34; invoke=\u0026#34;reverse\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; stringutils.js, das eine Funktion reverse enthält, muss sich in diesem Fall im gleichen Verzeichnis befinden.\n Ausgabe\n{palindrom: regallageR}  \n\n  java java übergibt Wert zur Tranformation einer Java-Klasse (class=, voller Name). Werte aller weiteren Attribute werden einer gleichnamigen setter-Methode der Klasse übergeben.\n  Beispiel   Eingabe\n{dekodiert: Eine strenggeheime Botschaft!}  Morph-Definition\n\u0026lt;data source=\u0026#34;dekodiert\u0026#34; name=\u0026#34;enkodiert\u0026#34;\u0026gt; \u0026lt;java class=\u0026#34;com.example.secret.Encoder\u0026#34; algorithm=\u0026#34;ROT13\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; Damit das Beispiel funktioniert, müsste ein Metafacture-Plugin die Klasse Encoder im angegebenen Klassenpfad zur Verfügung stellen. Zudem muss die Klasse eine setter-Methode setAlgorithm haben.\n Ausgabe\n{enkodiert: Rvar fgerattrurvzr Obgfpunsg!}  \n\n  count   count gibt Anzahl der aktuell gezählten Werte aus.\nUm nur den letzten Wert zu berücksichtigen, siehe das Rezept \u0026ldquo;Nur letzten Wert eines Literals berücksichtigen\u0026rdquo;.\n   Beispiel   Eingabe\n{litA: wert1, litA: wert2}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;count/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA: 1, litA: 2}   \n  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/literale/filter/",
	"title": "Filter",
	"tags": [],
	"description": "",
	"content": " Filterfunktionen filtern Literalwerte regelbasiert aus. In der Folge ein Überblick über die diesbezüglichen Möglichkeiten in Metamorph.\nwhitelist   whitelist filtert Werte basierend auf einer Whitelist (nur gelistete Werte werden weitergeleitet). Einträge sind in der Form \u0026lt;entry name=\u0026quot;wert\u0026quot;/\u0026gt;.\nFür weitere Informationen siehe Abschnitt \u0026ldquo;Nachschlagetabellen\u0026rdquo;\n   Beispiel   Eingabe\n{litA: erlaubt, litA: nicht erlaubt, litA: verboten, litA: indiziert, litA: genehm}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;whitelist\u0026gt; \u0026lt;entry name=\u0026#34;erlaubt\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;genehm\u0026#34;/\u0026gt; \u0026lt;/whitelist\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA:erlaubt, litA:genehm}   \n  blacklist   blacklist filtert Werte basierend auf einer Blacklist (gelistete Werte werden geblockt). Einträge sind in der Form \u0026lt;entry name=\u0026quot;wert\u0026quot;/\u0026gt;.\nFür weitere Informationen siehe Abschnitt \u0026ldquo;Nachschlagetabellen\u0026rdquo;\n   Beispiel   Eingabe\n{litA: erlaubt, litA: nicht erlaubt, litA: verboten, litA: indiziert, litA: genehm}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;blacklist\u0026gt; \u0026lt;entry name=\u0026#34;nicht erlaubt\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;verboten\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;indiziert\u0026#34;/\u0026gt; \u0026lt;/blacklist\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA:erlaubt, litA:genehm}   \n  equals / not-equals   equals /  not-equals leiten Literal nur dann (nicht) weiter, wenn sein Wert gleich wie Wert in string= ist.\n  Beispiel   Eingabe\n{litA: passt, litA: passt nicht}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;equals string=\u0026#34;passt\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;!-- Gleichbedeutend --\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;not-equals string=\u0026#34;passt-nicht\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA: passt}   \n  occurrence   occurrence leitet Literal ab (moreThan) oder bis (lessThan) zu einer gewissen Anzahl an Werten (only=) weiter.\nIn Kombination können moreThan und lessThan-Filter eingesetzt werden, um einen Teil aus einer Liste von Werten zu extrahieren (siehe Beispiel unten)\n   Beispiel   Eingabe\n{litA: wert1, litA: wert2, litA: wert3, litA: wert4}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34; name=\u0026#34;dritterWert\u0026#34;\u0026gt; \u0026lt;occurrence only=\u0026#34;moreThan 2\u0026#34;/\u0026gt; \u0026lt;occurrence only=\u0026#34;lessThan 2\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{dritterWert: wert3}   \n  unique   unique filtert doppelt vorkommende Werte aus\n in: Gleiche Werte in Entität (entity) oder Datensatz (record, Standard) part: Teile des Literals, die gleich sein müssen: name, value (Standard) oder name-value  Ein Wert in part abweichend von value ist nur dann sinnvoll, wenn globs für den Feldnamen verwendet werden.\n   Beispiel   Eingabe\n{litA: wertA, litA: wertB, litA: wertA, litB: wertA }  Morph-Definition\n\u0026lt;data source=\u0026#34;lit?\u0026#34;\u0026gt; \u0026lt;unique part=\u0026#34;name-value\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{litA: bezeugung}   \n  buffer   buffer hält Literale zurück, bis flush-Bedingung (flushWith=) erfüllt wird.\nFür weitere Informationen zu flushWith siehe Abschnitt \u0026ldquo;Ausgabesteuerung\u0026rdquo;.\n Wird flushWith= mit einem bestimmten Feldnamen angegeben, muss das entsprechende Literal als explizite Morph-Regel aufgeführt werden, und nicht etwa nur durch ein \u0026lt;data source=\u0026quot;_else\u0026quot;/\u0026gt;! Siehe dazu auch das Beispiel unten. Dies scheint ein Bug zu sein.\n   Beispiel   Eingabe\n{litA: wertA, litB: wertB, litC: wertC}  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;buffer flushWith=\u0026#34;litC\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;!-- litC muss explizit aufgeführt werden, da es ansonsten gar nicht ausgegeben wird. Siehe auch Hinweis oben. --\u0026gt; \u0026lt;data source=\u0026#34;litC\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;_else\u0026#34;/\u0026gt; Ausgabe\n{litB: wertB, lit }   \n  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/literale/nachschlagetabellen/",
	"title": "Nachschlagetabellen",
	"tags": [],
	"description": "",
	"content": " Nachschlagetabellen dienen zur Filterung oder Ersetzung bestimmter Werte und werden so von den Funktionen whitelist und blacklist sowie setreplace und lookup verwendet. Sie können in Metamorph an verschiedenen Stellen definiert werden:\n Wird die Nachschlagetabelle nur an einer einzigen Stelle benötigt, macht es Sinn, sie direkt in der Funktion des betreffenden Literal selbst zu definieren. Dies geschieht mithilfe des Enumerierungstags entry, welches das obligatorische Attribut name= (Schlüssel) und das fakultative Attribut value= (Ersetzungswert). Die vier erwähnten Funktionen haben auch ein fakultatives Attribut map=. Mit diesem kann eine im gesamten Morph verfügbare Tabelle referenziert werden, die in einem vom \u0026lt;rules\u0026gt;-Abschnitt separierten Tag \u0026lt;maps\u0026gt; definiert wird:\n\u0026lt;maps\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry name=\u0026#34;schluessel1\u0026#34; value=\u0026#34;wert1\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;schluessel2\u0026#34; value=\u0026#34;wert2\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/maps\u0026gt; Schliesslich kann ebenfalls im Tag \u0026lt;maps\u0026gt; analog zu map eine Reihe von externen Quellen als Nachschlagetabelle angegeben werden.\n  javamap javamap referiert eine Java-Klasse, welche java.util.Map implementiert\n name (obligatorisch): Name der Tabelle in Morph-Datei class (obligatorisch): Klassenname mit vollem Pfad Alle weiteren Attribute werden als Parameter der Klasse interpretiert  filemap   filemap referiert eine Textdatei, wobei in dieser eine Zeile einem Schlüssel-Wert-Paar entspricht\n name (obligatorisch): Name der Tabelle in Morph-Datei files (obligatorisch): Pfade zu Dateien mit Tabellen, getrennt durch Leerzeichen separator: Trennzeichen zwischen Schlüssel und Wert in Tabelle (Standard: \\t)  restmap   restmap fragt eine REST-Schnittstelle ab\n name (obligatorisch): Name der Tabelle in Morph-Datei url (obligatorisch): URL der REST-Schnittstelle  sqlmap   sqlmap fragt eine SQL-Datenbank ab\n name (obligatorisch): Name der Tabelle in Morph-Datei host: Hostname (Standard: localhost) login (obligatorisch): Benutzername password (obligatorisch): Passwort database (obligatorisch): Name der Datenbank query (obligatorisch): Suchabfrage driver: Datenbanktreiber (Standard: com.mysql.jdbc.Driver)  jndisqlmap   jndisqlmap fragt eine SQL-Datenbank über die JNDI-Schnittstelle ab\n name (obligatorisch): Name der Tabelle in Morph-Datei datasource (obligatorisch): Datenquelle query (obligatorisch): Suchabfrage  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/collectors/",
	"title": "Collectors",
	"tags": [],
	"description": "",
	"content": " In diesem Teil werden collectors behandelt, welche Literale aggregieren und diese zu einem definierbaren Zeitpunkt weiterleiten können.\nInhalt  Übersicht über vorhandene collectors Steuern, wenn gesammelte Werte weitergeleitet werden collectors bedingt erstellen  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/collectors/uebersicht/",
	"title": "Übersicht collectors",
	"tags": [],
	"description": "",
	"content": " Mithilfe von collectors können Werte verschiedener Literalen aggregiert, gefiltert oder zusammengefasst werden. Fast alle von ihnen teilen sich zwei Eigenschaften:\n Der Zeitpunkt und die Art der Emission ihrer Werte ist steuerbar. Es ist möglich, sie nur dann auszuführen, wenn gewisse Bedingungen erfüllt sind.  Zudem ist es für die collectors combine, concat, equalsFilter, square, tuples, choose, range und group möglich, mittels \u0026lt;postprocess\u0026gt; Literal-Funktionen auf das Ergebnis anzuwenden. Beispiel:\n\u0026lt;combine name=\u0026#34;neu\u0026#34; value=\u0026#34;${nachname}, ${vorname}\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;feld1\u0026#34; name=\u0026#34;vorname\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;feld2\u0026#34; name=\u0026#34;nachname\u0026#34;/\u0026gt; \u0026lt;postprocess\u0026gt; \u0026lt;trim/\u0026gt; \u0026lt;case to=\u0026#34;upper\u0026#34;/\u0026gt; \u0026lt;/postprocess\u0026gt; \u0026lt;/combine\u0026gt; Folgend eine Liste der verfügbare collectors in Metamorph.\nDie Attribute flushWith, reset und sameEntity, welche für die meisten collectors verwendet werden können, werden im nächsten Abschnitt beschrieben.\n combine   combine fügt Literale gemäss einem Template zusammen. Nachfolgende Werte überschreiben vorangehenden Werte desselben Feldes.\n name (erforderlich): Name des neuen Feldes value (erforderlich): Template. Werte von Feldern können mit ${feldname} eingefügt werden    Beispiel   Eingabe\n{ farbeA: grün, farbeA: gelb, farbeB: orange, farbeB: violet }  Morph-Definition\n\u0026lt;combine name=\u0026#34;mischung\u0026#34; value=\u0026#34;${a}${b}\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;farbeA\u0026#34; name=\u0026#34;a\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;farbeB\u0026#34; name=\u0026#34;b\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt; Ausgabe\n{ mischung: gelborange, mischung: gelbviolet }   \n  concat   concat fügt Literale in der angegebenen Reihenfolge in einem neuen Feld zusammen. Werte desselben Feldes werden konkateniert.\n name (erforderlich): Name des neuen Feldes delimiter: Trennzeichen zwischen einzelnen Literalen (Standard: \u0026quot;\u0026quot;) prefix: Präfix des neuen Feldes postfix: Suffix des neuen Feldes reverse: Fügt neue Literale am Anfang statt am Ende des neuen Feldes hinzu    Beispiel   Eingabe\n{ farbeA: grün, farbeA: gelb, farbeB: orange, farbeB: violet }  Morph-Definition\n\u0026lt;concat name=\u0026#34;mischung\u0026#34; delimiter=\u0026#34;\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;farbeA\u0026#34; name=\u0026#34;a\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;farbeB\u0026#34; name=\u0026#34;b\u0026#34;/\u0026gt; \u0026lt;/concat\u0026gt; Ausgabe\n{ mischung: grüngelborangeviolet }   \n  entity   entity erstellt mit den definierten Literalen eine neue (Sub-)Entität.\nname definiert den Namen der Entität, der alternativ auch mit dem entity-name-Element definiert werden kann. Wird weder name noch entity-name angegeben, wird ein leerer Name gesendet.\n  Beispiel   Eingabe\n{ farbeA: rot, farbeB: grün, farbeC: blau, farbeD: magenta }  Morph-Definition\n\u0026lt;entity name=\u0026#34;rgb\u0026#34; flushWith=\u0026#34;record\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;farbeA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;farbeB\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;farbeC\u0026#34;/\u0026gt; \u0026lt;/entity\u0026gt; \u0026lt;data source=\u0026#34;_else\u0026#34; /\u0026gt; flushWith=\u0026quot;record\u0026quot; sorgt dafür, dass die Literale erst am Ende des Datensatzes weitergeleitet werden. Für Details siehe das nächste Kapitel.\n Ausgabe\n{ farbeD: magenta, rgb { farbeA: rot, farbeB: grün, farbeC: blau }}  \n\n  square   square fügt Literale zu allen möglichen nicht-permutierten Zweierkombinationen zusammen. Werte desselben Feldes werden nicht überschrieben.\n name (erforderlich): Name der neuen 2er-Tupel delimiter (erforderlich): Trennzeichen zwischen den ausgegebenen Literalen prefix: Präfix der 2er-Tupel postfix: Suffix der 2er-Tupel    Beispiel   Eingabe\n{ litA: wertA1, litA: wertA2, litB: wertB1, litC: wertC1 }  Morph-Definition\n\u0026lt;square name=\u0026#34;paar\u0026#34; delimiter=\u0026#34;-\u0026#34; prefix=\u0026#34;@\u0026#34; postfix=\u0026#34;@\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litC\u0026#34;/\u0026gt; \u0026lt;/square\u0026gt; Ausgabe\n{ paar: @wertA1-wertC1@, paar: @wertA2-wertC1@, paar: @wertB1-wertC1@, paar: @wertA1-wertB1@, paar: @wertA2-wertB1@, paar: @wertA1-wertA2@ }   \n  tuples   tuples gibt alle möglichen nicht-permutierten Kombinationen der Literalwerte aus.\n name (erforderlich): Name der neuen Literale separator: Trennzeichen zwischen den Literalen    Beispiel   Eingabe\n{ litA: wertA1, litA: wertA2, litB: wertB }  Morph-Definition\n\u0026lt;tuples name=\u0026#34;gruppen\u0026#34; separator=\u0026#34;-\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/tuples\u0026gt; Ausgabe\n{ gruppen: wertA1-wertB, gruppen: wertA2-wertB }   \n  group   group gruppiert Literale und/oder collectors, normalerweise um ein gemeinsames Set an Funktionen auf sie anzuwenden.\n name: Neuer gemeinsamer Name value: Neuer gemeinsamer Wert    Beispiel   Eingabe\n{ kleinA: abc, kleinB: def }  Morph-Definition\n\u0026lt;group name=\u0026#34;GROSS\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;kleinA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;kleinB\u0026#34;/\u0026gt; \u0026lt;postprocess\u0026gt; \u0026lt;case to=\u0026#34;upper\u0026#34;/\u0026gt; \u0026lt;/postprocess\u0026gt; \u0026lt;/group\u0026gt; Ausgabe\n{ GROSS: ABC, GROSS: DEF }   \n  choose   choose sendet nur einen Literal aus einer Gruppe weiter (mit abnehmender Priorität).\n name: Name des neuen Literals value: Wert des neuen Literals    Beispiel   Eingabe\n{ wichtig: wichtig, vernachlässigbar: vernachlässigbar, unwichtig: unwichtig }  Morph-Definition\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;compose prefix=\u0026#34;be\u0026#34; postfix=\u0026#34;ung\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Ausgabe\n{ wichtig: wichtig }   \n  range   range wertet zwei aufeinanderfolgende Literale als ganze Zahlen aus, die den Start- und Endpunkt einer Zahlenreihe definieren. Alle Zahlen dieser Reihe werden anschliessend als Literale ausgegeben.\n name (obligatorisch): Name der neuen Literale increment: Inkrement (Standard: 1)    Beispiel   Eingabe\n{ anfang: 0, ende: 10 }  Morph-Definition\n\u0026lt;range name=\u0026#34;gerade zahl\u0026#34; increment=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;anfang\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;ende\u0026#34;/\u0026gt; \u0026lt;/range\u0026gt; Ausgabe\n{ gerade zahl: 0, gerade zahl: 2, gerade zahl: 4, gerade zahl: 6, gerade zahl: 8, gerade zahl: 10 }   \n  equalsFilter   equalsFilter gibt ein neues Literal aus, sofern die Werte der Literale alle gleich sind.\n name (obligatorisch): Name des neuen Literals value (obligatorisch): Wert des neuen Literals    Beispiel   Eingabe\n{ litA: gleich, litA: gleich, litB: gleich }  Morph-Definition\n\u0026lt;equalsFilter name=\u0026#34;alle waren gleich\u0026#34; value=\u0026#34;ja!\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/equalsFilter\u0026gt; Ausgabe\n{ alle waren gleich: ja! }   \n  all, any, none   all,  any und  none überprüfen, ob angegebenen Literale vorhanden sind. Sie geben standardmässig eine unbenannte (änderbar mit name=) Variable mit true als Wert (änderbar mit value=) aus, insofern die jeweilige Bedingung zutrifft:\n Bei all: Alle Literale sind im Datensatz vorhanden Bei any: Mindestens ein Literal ist im Datensatz vorhanden Bei none: Kein Literal ist im Datensatz vorhanden  Die Verwendung der drei Quantoren macht insbesondere Sinn im Zusammenhang mit if-Anweisungen.\n   Beispiel   Eingabe\n{litB: wertB}  Morph-Definition\n\u0026lt;all name=\u0026#34;alle vorhanden\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/all\u0026gt; \u0026lt;any name=\u0026#34;einige vorhanden\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/any\u0026gt; \u0026lt;none name=\u0026#34;keine vorhanden\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/none\u0026gt; Ausgabe\n{einige vorhanden: true}   \n  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/collectors/ausgabesteuerung/",
	"title": "Ausgabesteuerung",
	"tags": [],
	"description": "",
	"content": " Wann und wie collectors die gesammelten Werte weiterschicken, kann mit Hilfe von drei Parametern definiert werden: flushWith, reset und sameEntity.\nflushWith definiert den Zeitpunkt, zu welchem der collector die Werte abschickt (flush). Dies kann entweder nach der Verarbeitung eines bestimmten Feldes (flushWith=\u0026quot;feldname\u0026quot;, Wildcards erlaubt) oder des gesamten Datensatzes sein (flushWith=\u0026quot;record\u0026quot;). Im Fall von combine, entity, equalsFilter sowie den Quantoren all, any und none werden die gesammelten Werte standardmässig weitergeleitet, sobald für jedes Feld ein Wert vorhanden ist.\nIn einem collector gesammelte Werte werden nicht weitergeleitet, wenn die flushWith-Bedingung nicht eintritt. Dies ist der Fall, wenn\n der angegbene Feldname nicht vorhanden ist oder bei Standardeinstellung von combine, entity, equalsFilter, all, any und none der collector nicht gefüllt werden kann collector bis Ende des Datensatzes nicht gefüllt wird  Enthält ein collector keine Werte bei Eintreffen der flushWith-Bedingung, passiert ebenfalls nichts.\n reset löscht alle gesammelten Werte, nachdem diese weitergeleitet wurden. Ist reset=\u0026quot;false\u0026quot;, werden also nach einem erstmaligen flush die aktuell im collector gespeicherten Werte bei jedem neu gesammelten Wert von Neuem abgeschickt!\nsameEntity leitet nur Werte weiter, die in derselben Literalgruppe (entity) gesammelt wurden. Ist die Literalgruppe fertig prozessiert, ohne dass für jedes Feld ein Wert vorhanden ist, werden die gespeicherten Werte weggeworfen. Der reset-Mechanismus wird anderseits bei sameEntity=\u0026quot;true\u0026quot; unabhängig von der Einstellung des reset-Paraemters ausgelöst, konnte die flush-Bedingung in einer Literalgruppe erfüllt werden.\nIm Fall von combine überschreiben neue ältere Werte des gleichen Datenfeldes.\n Standardeinstellungen für flushWith, reset und sameEntity    Collector flushWith reset sameEntity     combine wenn vollständig false false   concat record true false   entity wenn vollständig false false   squares record true entfällt   tuples record entfällt entfällt   group entfällt entfällt entfällt   choose record true false   range record false false   equalsFilter wenn vollständig false false   all wenn vollständig false false   any wenn vollständig false false   none wenn vollständig false false    "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/collectors/if-anweisungen/",
	"title": "if-Anweisungen",
	"tags": [],
	"description": "",
	"content": "Mithilfe von if-Anweisungen lässt sich steuern, ob ein collector Werte ausgibt oder nicht. Die Syntax sieht folgendermassen aus:\n\u0026lt;combine name=\u0026#34;ausgabe\u0026#34; value=\u0026#34;${a}+${b}\u0026#34;\u0026gt; \u0026lt;if\u0026gt; \u0026lt;data source=\u0026#34;feldA\u0026#34;\u0026gt; \u0026lt;equals string=\u0026#34;wertA\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;data source=\u0026#34;feldA\u0026#34; name=\u0026#34;a\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;feldB\u0026#34; name=\u0026#34;b\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt; Wenn der Wert im feldA tatsächlich wertA ist, dann wird das Ergebnis von ${a}+${b} ausgegeben, ansonsten nicht.\nIn der if-Anweisung lässt sich jede Filter-Funktion sowie die collectors all, any und none verwenden. Ein Beispiel mit all:\n\u0026lt;combine name=\u0026#34;ausgabe\u0026#34; value=\u0026#34;${a}+${b}\u0026#34;\u0026gt; \u0026lt;if\u0026gt; \u0026lt;all\u0026gt; \u0026lt;data source=\u0026#34;feldA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;feldB\u0026#34;/\u0026gt; \u0026lt;/all\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;data source=\u0026#34;feldA\u0026#34; name=\u0026#34;a\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;feldB\u0026#34; name=\u0026#34;b\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt; Wenn beide Literale einen Wert liefern, wird das Ergebnis von ${a}+${b} weitergeleitet.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/modularisierung/",
	"title": "Modularisierung",
	"tags": [],
	"description": "",
	"content": " Der Teil stellt verschiedene Methoden vor, wie Literale und Morph-Definitionen wiederverwendet werden können.\nInhalt  Mittels Rekursion Literale wiederverwenbar machen Variablen nutzen Funktionen definieren Morph-Dateien modularisieren  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/modularisierung/rekursion/",
	"title": "Rekursion",
	"tags": [],
	"description": "",
	"content": "Normalerweise wird ein Literal direkt nach seiner Verarbeitung an das nächste command weitergeleitet. Es ist durch eine spezielle Syntax - ein führendes @ im Namen - allerdings möglich, seine Werte bis zum Prozessierungsende des Datensatzes im Cache zu halten:\n\u0026lt;data source=\u0026#34;eingabename\u0026#34; name=\u0026#34;@loop\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;@loop\u0026#34; name=\u0026#34;ausgabename\u0026#34;/\u0026gt; Bei der Verwendung dieser Syntax sind einige Dinge zu beachten:\n Literale im Cache müssen bei jeder Wiederverwendung umbenannt werden, da sonst eine unendliche Schleife entsteht (aka ein StackOverflowError). Das heisst also, dass beispielsweise folgendes Konstrukt nicht möglich ist:\n\u0026lt;data source=\u0026#34;eingabename\u0026#34; name=\u0026#34;@loop\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;@loop\u0026#34;/\u0026gt; \u0026lt;!-- name-Attribut fehlt! --\u0026gt; Ein literales @ als erstes Zeichen eines Feldnamens ist möglich, wenn es durch einen vorangehenden \\ seiner speziellen Bedeutung \u0026ldquo;beraubt\u0026rdquo; wird (\\ erscheint anschliessend nicht mehr im Namen). \\ ist nicht notwendig, wenn sich das betreffende Literal bzw. der betreffende collector innerhalb eines Eltern-collectors befindet (siehe dazu auch den nächsten Punkt).\n Literale bzw. collectors, welche innerhalb eines anderen collectors in die Rekursion geschickt werden, werden gleichzeitig immer auch literal weitergeleitet (also bspw. als (\u0026quot;@feldname\u0026quot;: \u0026quot;feldwert\u0026quot;)). Da dieses Verhalten ist in der Regel nicht gewünscht, deshalb sollten Rekursionen grundsätzlich ausserhalb von Eltern-collectors definiert werden.\n  Durch Rekursion lassen sich verschiedene Probleme lösen, so:\n Eine initiale Verarbeitung eines Literals lässt sich zentral definieren, die Ausgabe lässt sich an verschiedenen Orten im Morph wiederverwenden (beispielsweise in einem collector) Das Ergebnis eines collector, der vor Ende des Datensatzes \u0026ldquo;geflusht\u0026rdquo; werden muss, soll in einem anderen collector genutzt werden  Allerdings gibt es auch Einschränkungen. Der gecachte Literal verhält sich aus Sicht der ihn aufrufen Morph-Definition wie ein Iterator: Jeder seiner Werte kann nur einmal wiederverwendet werden und geht dann verloren. Es ist zudem nicht möglich, einen gecachten Literal gestaffelt abzuarbeiten.\nBeispiel Eingabe\n{ litA: wertAA, litA: wertAB, litB: wertBA, litB: wertBB }  Morph-Definitionen\n\u0026lt;rules\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34; name=\u0026#34;@loop\u0026#34;/\u0026gt; \u0026lt;entity name=\u0026#34;entAB\u0026#34; flushWith=\u0026#34;litB\u0026#34; reset=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;@loop\u0026#34; name=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34; name=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/entity\u0026gt; \u0026lt;/rules\u0026gt; Ausgabe\n{ entAB { litA: wertAA, litA: wertAB, litB: wertBA }, entAB { litB: wertBB } }    "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/modularisierung/variablen/",
	"title": "Variablen",
	"tags": [],
	"description": "",
	"content": "Werte in Metamorph sind bis zu einem gewissen Grad dynamisierbar, indem sie als Parameter in der Flux-Datei oder über die Kommandozeile dem Programm übergeben werden. Dazu ist es notwendig, dass in der Flux-Datei das morph-command so angepasst wird, dass solche Parameter automatisch der Metamorph-Klasse übergeben werden:\nmorph(morphdatei, *)  Anschliessend können arbiträre Parameter in Flux definiert werden:\ndefault var1 = \u0026quot;wert1\u0026quot;; default var2 = \u0026quot;wert2\u0026quot;; // Flux-Commands...  default verhindert, dass bereits auf der Kommandozeile definierte Parameter überschrieben werden. Letzteres kann folgendermassen bewerkstelligt werden:\n./flux.sh fluxdatei var1=wert1 var2=wert2  In Metamorph werden so übergebene Parameter mittels $[variablenname] etc. ausgelesen, also beispielsweise:\n\u0026lt;data source=\u0026#34;_id\u0026#34; name=\u0026#34;feldA\u0026#34;\u0026gt; \u0026lt;constant value=\u0026#34;$[var1]\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; Selbstredend können solche Variablen überall dort in Metamorph-Definitionen verwendet werden, wo auch Werte definiert werden können.\nSchliesslich lassen sich in Metamorph auch noch Standardwerte für Variablen definieren. Dies geschieht in einem vom \u0026lt;rules\u0026gt;-Element separierten \u0026lt;vars\u0026gt;-Tag:\n\u0026lt;vars\u0026gt; \u0026lt;var name=\u0026#34;var1\u0026#34; value=\u0026#34;wert1\u0026#34;/\u0026gt; \u0026lt;var name=\u0026#34;var2\u0026#34; value=\u0026#34;wert2\u0026#34;/\u0026gt; \u0026lt;/vars\u0026gt; \u0026lt;!-- \u0026lt;rules\u0026gt; ... --\u0026gt;"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/modularisierung/makros/",
	"title": "Makros",
	"tags": [],
	"description": "",
	"content": "Noch einen Schritt weiter als Variablen hinsichtlich der Wiederverwendbarkeit gehen Makros. Mit ihnen lassen sich eigentliche parametrisierbare Funktionen innerhalb der Morph-Datei definieren. Wie Variablen werden sie ausserhalb des \u0026lt;rules\u0026gt;-Elementes definiert, in diesem Fall im \u0026lt;macros\u0026gt;-Tag:\n\u0026lt;macros\u0026gt; \u0026lt;macro name=\u0026#34;eindeutiger_name\u0026#34;\u0026gt; \u0026lt;!-- Makro --\u0026gt; \u0026lt;/macro\u0026gt; \u0026lt;!-- Weitere Makros --\u0026gt; \u0026lt;/macros\u0026gt; \u0026lt;!-- \u0026lt;rules\u0026gt; ... --\u0026gt; Ein Makro muss zwingend mit einem eindeutigen Namen (name=) versehen werden, damit es später im \u0026lt;rules\u0026gt;-Block aufgerufen werden kann.\nMakros können einen beliebigen Block an Metamorph-Definitionen enthalten, also Literale mit ihren Funktionen, collectors sowie eine Kombination davon. Parameter werden wie Variablen in eckigen Klammern mit führendem Dollarzeichen geschrieben ($[param1]). Ein Beispiel eines einfachen Makros:\n\u0026lt;macro name=\u0026#34;makro1\u0026#34;\u0026gt; \u0026lt;concat delimiter=\u0026#34; \u0026#34; name=\u0026#34;$[ccName]\u0026#34; flushWith=\u0026#34;$[abschickenMit]\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;$[dsSource]\u0026#34; \u0026gt; \u0026lt;case to=\u0026#34;upper\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/concat\u0026gt; \u0026lt;/macro\u0026gt; Makros werden mit dem Element \u0026lt;call-macro\u0026gt; aufgerufen. call-macro umfasst ein obligatorisches Attribut, der Name des Makros (name=). Alle weiteren Attribute werden als Argumente des Makros interpretiert. Das obige Makro wird also beispielsweise folgendermassen aufgerufen\u0026gt;\n\u0026lt;combine name=\u0026#34;name\u0026#34; value=\u0026#34;${vorname} ${nachname}\u0026#34;\u0026gt; \u0026lt;call-macro name=\u0026#34;makro1\u0026#34; ccName=\u0026#34;vorname\u0026#34; dsName=\u0026#34;feldA\u0026#34; abschickenMit=\u0026#34;nachname\u0026#34; /\u0026gt; \u0026lt;data source=\u0026#34;feldB\u0026#34; name=\u0026#34;nachname\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt;"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/modularisierung/includes/",
	"title": "Includes",
	"tags": [],
	"description": "",
	"content": "Um Code-Blöcke nicht nur innerhalb einer Morph-Datei wiederzuverwenden, sondern auch zwischen Dateien zu teilen, können schliesslich sogenannte XML inclusions (oder kurz XInclude) verwendet werden. Solche inclusions sind möglich direkt im \u0026lt;metamorph\u0026gt;-Element, aber auch als Kind-Elemente von \u0026lt;rules\u0026gt;, \u0026lt;maps\u0026gt; und \u0026lt;macros\u0026gt;. Das heisst also, einfügbare Bausteine können Definitionen, Mappings, Makros oder der vollständige Inhalt einer Morph-Datei sein.\nBausteine und die sie verwendenden Morph-Definitionen sind zur Laufzeit eine einzige Einheit. Somit können beispielsweise Werte im Block in eine Rekursion geschickt werden und in der Hauptdatei wieder ausgelesen, oder in einem Block definierte Nachschlagetabellen in der Morph-Datei aufgerufen werden.\nAus diesem Grund haben Blöcke nie ein \u0026lt;metamorph\u0026gt;- und, werden sie direkt in einem der Kindelemente verwendet, auch kein \u0026lt;rules\u0026gt;-, \u0026lt;maps\u0026gt;- oder \u0026lt;macros\u0026gt;-Element.\n Eingefügt werden XML inclusions folgendermassen:\n\u0026lt;include href=\u0026#34;pfad/zum/einzufuegenden/block.xml\u0026#34; parse=\u0026#34;xml\u0026#34; xmlns=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34; /\u0026gt; Während der Block beispielsweise so aussehen kann:\n\u0026lt;!-- block.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.1\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;map name=\u0026#34;hauptorte\u0026#34; xmlns=\u0026#34;http://www.culturegraph.org/metamorph\u0026#34;\u0026gt; \u0026lt;entry name=\u0026#34;Aargau\u0026#34; value=\u0026#34;Aarau\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;Appenzell Ausserrhoden\u0026#34; value=\u0026#34;Herisau\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;Appenzell Innerrhoden\u0026#34; value=\u0026#34;Appenzell\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;Basel-Landschaft\u0026#34; value=\u0026#34;Liestal\u0026#34;/\u0026gt; \u0026lt;entry name=\u0026#34;Basel-Stadt\u0026#34; value=\u0026#34;Basel\u0026#34; /\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/map\u0026gt;"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/kochbuch/",
	"title": "Kochbuch",
	"tags": [],
	"description": "",
	"content": " In diesem Teil werden Lösungsstrategien (\u0026ldquo;Rezepte\u0026rdquo;) für spezifische Probleme in Metamorph präsentiert.\nInhalt  Literale in Entitäten wiederverwenden Ordnung von Feldwerten in einem Literal umdrehen Ordnung von Literalen ändern Nur letzten Wert eines Literals berücksichtigen  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/kochbuch/literale-in-entitaeten-wiederverwenden/",
	"title": "Literale in Entitäten wiederverwenden",
	"tags": [],
	"description": "",
	"content": " Problem Ein Literal (litA) soll mit einem mehrfach vorhandenen weiteren Literal (litB) in einer Entität zusammenfügt werden, wobei für jedes litB eine Entität erstellt wird.\nEingabe\n{litA: wertA, litB: wertB, litB: wertC}  Erwartete Ausabe\n{entAB {litA: wertA, litB: wertB} entAB {litA: wertA, litB: wertC}}  Lösung \u0026lt;entity name=\u0026#34;entAB\u0026#34; flushWith=\u0026#34;litB\u0026#34; reset=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;combine name=\u0026#34;litA\u0026#34; value=\u0026#34;${litA}\u0026#34; flushWith=\u0026#34;litB\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34; name=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/entity\u0026gt; litA wird in einem combine-collector \u0026ldquo;gespeichert\u0026rdquo;, der in diesem Fall wie ein Cache benutzt werden kann. Wichtig ist, dass der collector zur gleichen Zeit weitergeleitet wird wie die ihn umgebende entity, da ansonsten der in ihm aggregierte Wert nur einmal (nämlich wenn er das erste Mal gefüllt ist) \u0026ldquo;geflusht\u0026rdquo; wird.\nAnaloges gilt für concat.\n Bemerkungen Andere, vermutlich naheliegendere Strategien funktionieren nicht\nDirektes Auslesen des Literals \u0026lt;entity name=\u0026#34;entAB\u0026#34; flushWith=\u0026#34;litB\u0026#34; reset=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34; name=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/entity\u0026gt; Ausgabe:\n{entAB {litA: wertA, litB: wertB} entAB {litB: wertC}}  Da das Feld litA vor litB ausgelesen und im entity-Block nach der Verarbeitung des ersten litB geflusht wird, steht es zum Zeitpunkt des zweiten litB nicht mehr zur Verfügung.\nEntität nicht zurücksetzen \u0026lt;entity name=\u0026#34;entAB\u0026#34; flushWith=\u0026#34;litB\u0026#34; reset=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;combine name=\u0026#34;litA\u0026#34; value=\u0026#34;${litA}\u0026#34; flushWith=\u0026#34;litB\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;/combine\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34; name=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/entity\u0026gt; Ausgabe:\n{entAB {litA: wertA, litB: wertB} entAB {litA: wertA, litB: wertB, litB: wertC}}  Nicht möglich, da so alle Werte in entity gesammelt werden. Allerdings würde diese Strategie beispielsweise für combine funktionieren, da in diesem Fall Werte mit gleichem Feldnamen überschrieben werden.\nRekursives Zugreifen auf litA \u0026lt;data source=\u0026#34;litA\u0026#34; name=\u0026#34;@loop\u0026#34;/\u0026gt; \u0026lt;entity name=\u0026#34;entAB\u0026#34; flushWith=\u0026#34;litB\u0026#34; reset=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;@loop\u0026#34; name=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;data source=\u0026#34;litB\u0026#34; name=\u0026#34;litB\u0026#34;/\u0026gt; \u0026lt;/entity\u0026gt; Ausgabe:\n{entAB {litA: wertA, litB: wertB} entAB {litB: wertC}}  Zwar ist der Wert von litA über die ganze restliche Prozessierungszeit des Records im Cache gespeichert, doch kann pro Zugriffsort nur einmal über ihn iteriert werden.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/kochbuch/ordnung-von-feldwerten-umdrehen/",
	"title": "Ordnung von Werten in einem Literal umdrehen",
	"tags": [],
	"description": "",
	"content": " Problem Ein Literal (litA) hat mehrere Werte in der Reihenfolge wert1, wert2. Diese Reihenfolge soll umgedreht werden.\nEingabe\n{ litA: wert1, litA: wert2 }  Erwartete Ausgabe\n{ litA: wert2, litA: wert1 }  Lösung \u0026lt;concat name=\u0026#34;litA\u0026#34; delimiter=\u0026#34;-\u0026#34; reverse=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;/\u0026gt; \u0026lt;postprocess\u0026gt; \u0026lt;split delimiter=\u0026#34;-\u0026#34;/\u0026gt; \u0026lt;/postprocess\u0026gt; \u0026lt;/concat\u0026gt; Werte werden mit concat in einem String, wobei neue Werte mit reverse=\u0026quot;true\u0026quot; jeweils vorne angefügt werden. Anschliessend wird mit der Funktion split der konkatenierte Wert entlang eines Zeichens (hier -) wieder aufgetrennt. Natürlich sollte das verwendete Zeichen nicht als Wert im Literal vorkommen, deshalb ist in der Praxis die Verwendung eines selteneren Zeichens als - ratsam.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/kochbuch/ordnung-von-literalen-aendern/",
	"title": "Ordnung von Literalen ändern",
	"tags": [],
	"description": "",
	"content": " Problem Ein Literal (litA) wird vor einem anderen (litB) prozessiert. Nun soll aber diese Reihenfolge umgedreht werden.\nEingabe\n{ litA: wertA, litB: wertB }  Erwartete Ausgabe\n{ litB: wertB, litA: wertA }  Lösung \u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;buffer flushWith=\u0026#34;record\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;data source=\u0026#34;_else\u0026#34;/\u0026gt; Mit der Funktion buffer lässt sich ein Literal an einer beliebigen Stelle weiterleiten, in diesem Fall erst am Ende des Datensatzes anstatt gleich nach der Bearbeitung des entsprecechenden Literals. Mit \u0026lt;data source=\u0026quot;_else\u0026quot;/\u0026gt; wird sichergestellt, dass auch Literale weitergeleitet werden, für die keine explizite Regel besteht.\nBemerkungen Sollen mehrere Literale in ihrer Reihenfolge verändert werden, ist es sinnvoll, mehrere morph-commands hintereinander zu schalten, und in jeder Morph-Datei ein Literal an das Ende zu verschieben (\u0026lt;data source=\u0026quot;_else\u0026quot;/\u0026gt; nicht vergessen!).\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/kochbuch/nur-letzten-wert-beruecksichtigen/",
	"title": "Nur letzten Wert eines Literals berücksichtigen",
	"tags": [],
	"description": "",
	"content": " Problem Von einem Literal (litA) sollen die Werte gezählt werden, doch interessiert nur die letzte Zählung (das heisst die Zählung über alle Werte).\nEingabe\n{ litA: wert1, litA: wert2 }  Erwartete Ausgabe\n{ litA: 2 }  Lösung \u0026lt;combine name=\u0026#34;litA\u0026#34; value=\u0026#34;${litA}\u0026#34; flushWith=\u0026#34;record\u0026#34;\u0026gt; \u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;count /\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/combine\u0026gt; Die Lösung macht sich zunutze, dass combine Werte überschreibt. Wird erst am Ende des Datensatzes weitergeleitet, verbleibt also nur die Zählung über alle Werte von litA.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/anhang/",
	"title": "Anhang",
	"tags": [],
	"description": "",
	"content": " Zusätzliche Informationen\nInhalt  Metamorph mit eigenen Funktionen erweitern Besprechung von Morph-Definitionen in linked-swissbib Metafacture / Metamorph: Ressourcen im Internet Glossar (kommt noch)  "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/anhang/metamorph-erweitern/",
	"title": "Metamorph erweitern",
	"tags": [],
	"description": "",
	"content": " Metamorph kann mit eigenen Java-Klassen oder Javascript-Funktionen erweitert werden. Während im Kapitel \u0026ldquo;Transformationen\u0026rdquo; bereits die beiden entsprechenden Morph-Funktionen, java und script, vorgestellt wurden, werden an dieser Stelle Hinweise zur Implementation gegeben. Da dies weniger mit Metamorph selbst als mit der API von Metafacture zu tun hat, befindet sich dieses Kapitel im Anhang.\nErweitern mit einer Java-Klasse AbstractStatefulFunction, AbstractSimpleStatelessFunction sowie ihrer Kindklasse AbstractFilter\nErweitern mit einer Javascript-Funktion Die Javascript-Funktion muss ein Argument - den Wert des Literals - entgegennehmen können und ein Wert eines beliebigen Typs zurückgeben. Die die Funktion aufrufende Java-Klasse wendet dann die toString()-Methode auf den Rückgabewert an und gibt den Wert an die verarbeitende Metamorph-Funktion zurück. Ein Beispiel:\n// script.js // Funktioniert nur für Strings mit ASCII-Zeichen! function asciiReverse(val){ return val.split(\u0026#34;\u0026#34;).reverse().join(\u0026#34;\u0026#34;); }  In Metamorph wird die Funktion folgendermassen aufgerufen:\n\u0026lt;data source=\u0026#34;litA\u0026#34;\u0026gt; \u0026lt;!-- Pfade sind relative zur Basis-URI --\u0026gt; \u0026lt;script file=\u0026#34;script.js\u0026#34; envoke=\u0026#34;asciiReverse\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt;"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/anhang/lsb-morphs/",
	"title": "Morphs in linked-swissbib",
	"tags": [],
	"description": "",
	"content": " documentMorph.xml Erstellt Metadaten der Aufnahme. Pro bibliographicRecord-Ressource sollte auch eine document-Ressource vorhanden sein.\nenrichedMorph.xml Verarbeitet Datensätze im NTriples-Format und transformiert sie zu JSON-LD. Datensatz-Typen sind \u0026ldquo;Organisationen\u0026rdquo; (siehe Anmerkungen dazu im Abschnitt \u0026ldquo;organisationMorph.xml\u0026rdquo;) und \u0026ldquo;Personen\u0026rdquo;. Aufgrund der Syntax-Spezifika von NTriples sowie für die Normalisierung der Inputdaten, welche aus heterogenen Quellen stammen (DBPedia, VIAF, vorverarbeitete Swissbib-Daten), müssen die meisten Werte modifiziert werden. Die drei wichtigsten Fälle, die jeweils in einem \u0026lt;macro\u0026gt;-Element definiert werden:\n Makro year: Jahresangaben sind immer nur auf das (vierstellige) Jahr genau, und nicht etwa in der Form yyyy-mm-dd. Makro uri: DBPedia-Links sollen immer zu https://-Links umgewandelt werden Makro language-tag: Das Sprach-Tag, welches in NTriples mit einem @-Trennzeichen an das Literal angefügt wird, wird abgetrennt und in ein eigenes Literal (lang überführt).  Personen und \u0026ldquo;Organsationen\u0026rdquo; haben verschiedene JSON-LD-Kontexte. Daher gibt es zwei \u0026lt;combine\u0026gt;-Blöcke zur Erstellung des jeweiligen Kontextes, wo überprüft wird, ob es sich um einen Datensatz vom Typ Person oder Organization handelt. Je nach dem werden im betreffenden Kontext-Block die Daten weitergeleitet oder nicht.\nitemMorph.xml Erstellt Exemplardaten primär basierend auf dem nicht-kanonischen MARC-Feld 949. Hinweise:\n Die ID ist eine Kombination aus einem konstanten Präfix - https://data.swissbib.ch/item/ -, dem Namen des Verbundes (Information aus Unterfeld 949??.B) sowie einem eindeutigen Hash-Wert, der auf verschiedenen Werten aus den 949er-Unterfeldern beruht. Der Hashwert wird mit der Klasse ItemHash erstellt. In einer bibliographischen Aufnahme können selbstverständlich Daten zu mehreren Exemplaren vorhanden sein. Dazu wird ein spezielles Verfahren genutzt, welches Entitäten erstellt und in einem weiteren command diese zu eigenen records umwandelt. Für Details siehe Hinweis-Block unten. Der \u0026lt;combine\u0026gt;-Block, wo der Hashwert generiert wird, befindet sich ausserhalb des \u0026lt;entity\u0026gt;-Blocks. Grund dafür ist das spezielle Verhalten von Rekursionen, welche innerhalb von collectors initialisiert werden. Für Details siehe Hinweise im entsprechenden Kapitel. In einem weiteren \u0026lt;combine\u0026gt;-Element, foaf:page, wird ein Link zum Katalogisat im jeweiligen Katalog erstellt. Dazu werden verschiedene Werte an eine weitere Klasse zur Verarbeitung geschickt, ItemLink.  Ein wiederholt genutzte Methode für Extraktion von mehreren eigenständigen Ressourcen aus einer einzigen bibliographischen (Eingabe-)Ressource ist die Erstellung von Entitäten (entity) in der betreffenden Morph-Datei. Dieser entity-Block umfasst alle Literale, welche für die jeweilige Zielressource benötigt werden. Nach dem morph-command folgt entity-splitter, das einzelne Entitäten eines Records einliest, diese aber als eigentständige Records wieder ausgibt. Mithilfe des Parameters entityBoundary lässt sich zudem für mehrfach geschachtelte Entitäten einstellen, ab welcher Stufe die Entitäten Records werden sollen.\n organisationMorph.xml Erstellt \u0026ldquo;Organisations\u0026rdquo;-Entitäten (Organisationen, Institutionen, Kongresse etc.) auf Basis von Marc-Feld 110, 111, 710 oder 711.\n Um solche Entitäten zu erstellen, wird der entity-collector verwendet. Solche Unter-Entitäten werden dann im nächsten Metafacture-Schritt zu eigenen Records \u0026ldquo;aufgewertet\u0026rdquo;. Für Details siehe Hinweis-Block in Abschnitt \u0026ldquo;itemMorph.xml\u0026rdquo;. Da der Identifier analog zu resourceMorph.xml und organisationMorph.xml mit dem Hash-Mechanismus erstellt wird, ist es für Entitäten aus den Feldern 110 und 111 zwingend, dass sie erst mit Unterfeld 245*.a weitergeleitet werden. Damit eine Entität für Feld 110 oder 111 nicht \u0026ldquo;aus Versehen\u0026rdquo; weitergeleitet wird (sprich: es gibt in der Ressource gar kein entsprechendes Feld), ist es wichtig, dass alle Bestandteile des collectors nur getriggert werden, wenn tatsächlich ein entsprechendes (Unter-)Feld vorhanden ist. Denn wie im Kapitel \u0026ldquo;Ausgabesteuerung\u0026rdquo; beschrieben, wird ein collector auch bei einem expliziten flushWith nur weitergeleitet, wenn er nicht leer ist. Entsprechend abgesichert wird an verschiedenen Stellen: Alle Literale (auch Konstanten) haben als Source 110??, 111?? oder eines ihrer Unterfelder; dasselbe gilt für Literale in Kind-collectors; schliesslich wird bei der Hashwert-Generierung in authorHash110 und authorHash111 mit einer if-Anweisung getetest, ob entsprechende Unterfelder vorhanden sind - ansonsten wird kein Hash (auch kein NO_HASH!) generiert. Dieselbe Vorsichtsmassnahme ist für Entitäten der Felder 710 und 711 nicht notwendig, da sie mit dem demselben Feld getriggert werden, aus dem sie ihre Werte beziehen.  personMorph.xml Erstellt Personen-Entitäten auf Basis von MARC-Feld 100 (1. Indikator 0 oder 1) oder 700 (1. Indikator dito). Der grundsätzlich Mechanismus ist derselbe wie bei itemMorph.xml und organisationMorph.xml: Literale werden pro relevantem Feld in entity-Blöcke zusammengefasst und anschliessend zu eigenständigen Ressourcen umgewandelt (für genauere Erläuterungen dazu s. Info-Box im Abschnitt zu itemMorph.xml). Zudem sind dieselben \u0026ldquo;Sicherheitsmassnahmen\u0026rdquo; wie bei organisationMorph.xml für Feld 100-Fälle implementiert, um ein unabsichtliches Weiterleiten einer Entität ohne Werte aus dem entsprechenden Feld zu verhindern.\nresourceMorph.xml Erstellt das eigentliche Katalogisat und linkt (bzw. wird verlinkt durch) die Ressourcen Person, Organisation, Document, Item sowie die separat erstellte Work.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/anhang/ressourcen/",
	"title": "Ressourcen",
	"tags": [],
	"description": "",
	"content": " Praxis  Metafacture-Code auf Github Metafacture-Wiki Metamorph-Schema Alte Metafacture-Organisation auf Github Metafacture: Beispiele Metafacture Java Examples Docker Image für Metafacture Standalone (experimentell)  Theorie  Analysis of library metadata with Metafacture (Vortrag Christoph Böhme) Metamorph: A Transformation Language for Semi-structured Data Das Metamorph-Datenmodell  linked-swissbib  linked-swissbib-Organisation auf Github, insbesondere:  mfWorkflows (Morph-Definitionen) swissbib-metafacture-commands (linked-swissbib Plugin für Metafacture)  Artikel-Reihe zu linked-swissbib:  Swissbib data goes linked 1: Metadatentransformation, Modellierung, Indexierung Swissbib data goes linked 2: Verlinkung und Anreicherung Swissbib data goes linked 3: Präsentation der angereicherten Daten Swissbib data goes linked Teil 4: Hydra Web API for smarter clients   "
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/",
	"title": "Homepage",
	"tags": [],
	"description": "",
	"content": "Zur Datentransformation und zum Datenmapping im Rahmen des Projektes linked-swissbib verwenden wir fast ausschliesslich das Framework Metafacture. Da dieses Feld durchaus seine Schwierigkeiten und Tücken hat, ist auch die Handhabung des Frameworks nicht ganz einfach. Insbesondere der \u0026ldquo;Kern\u0026rdquo; von Metafacture, Metamorph, mit dem die Transformations- und Mappingregeln definiert werden, ist anspruchsvoll. Auf Grundlage unserer Erfahrungen haben wir die vorliegende Dokumentation geschrieben.\nIm ersten Teil werden die Grundlagen von Metamorph vorgestellt: Bearbeitung einzelner Literale (Schlüssel-Wert-Paare), Prozessierung von Literalverbünden (collectors) sowie die Wiedernutzung von einzelnen Literalen und Morph-Definitionen. Der Inhalt orientiert sich an der offiziellen Metafacture-Dokumentation und am XML-Schema von Metamorph, versucht aber auch, einzelne Konzepte, die uns nicht auf Anhieb klar waren, genauer zu beleuchten.\nHinweise zu weiteren Metafacture-Ressourcen finden sich im Anhang\n Da wir aus unseren Erfahrungen mit linked-swissbib gelernt haben, dass die korrekte Anwendung von Metamorph-Regeln in Einzelfällen tückisch sein kann, werden im zweiten Teil in Form eines \u0026ldquo;Kochbuches\u0026rdquo; \u0026ldquo;Rezepte\u0026rdquo; für einzelne Problemstellungen vorgestellt. Es versteht sich von selbst, dass dieser Teil keinen Anspruch auf Vollständigkeit erhebt. Ergänzungen sind natürlich herzlich willkommen.\nIm Anhang schliesslich finden sich neben einem Glossar und einer Liste von Ressourcen zu Metamorph/Metafacture im Netz auch eine Besprechung der in linked-swissbib verwendeten Metamorph-Definitionen. Dieser Abschnitt stellt eine Ergänzung zu den in den ersten beiden Teilen vorgestellten Inhalten dar.\n"
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://sschuepbach.github.io/metamorph-hacks/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]